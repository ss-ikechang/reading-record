# 概要

## 本

- [コンパイラの構成と最適化 | 中田 育男](https://amzn.to/36jzadN)

## かかった時間

- x 時間

## 読む前の状態

- [コンピュータシステムの理論と実装](../docs/nand2tetris.md) でコンパイラの基礎は理解していた
- 「コンパイラの理論をもう少し深く知りたい」「最適化のところを知りたい」というモチベーションでやることにした

# 読書メモ

## 1章: はじめに

- コンパイラとは、高級プログラム言語で書かれたプログラムを、機械向き言語のプログラムに翻訳するためのプログラム
  - 機械向き言語には、仮想マシンの機械語も含む
- 原始プログラムのコンパイルから実行までに必要なすべてのシステムをあわせたものを言語処理系（または処理系）と呼ぶ

## 2章: コンパイラの簡単な例

- 記法の説明
  - 中置記法（a+b）
  - 前置記法（+ab）
    - ポーランド記法ともいう
  - 後置記法（ab+）
    - 逆ポーランド記法ともいう
- 後置記法の性質は、計算機で計算する時に都合がいい。計算機は後置記法の式の各項目を、並んでいる順番に計算すればいい
- 中置記法の式を後置記法に変換するアルゴリズム
  - スタックに左括弧（どの演算子よりも優先順位の低い演算子）を積む
  - 中置記法の式を左から読みながら
    - 演算数を読んだらそれをそのまま出力する（演算数:式が 1 つのもの。a とか）
    - 演算子を読んだら、スタックの上にそれより優先順位の高い演算子があればそれを（あるだけ順に）スタックから降ろして出力し、読んだ演算子をスタックに積む。ただし、式の終わりになったら、右括弧（どの演算子よりも優先順位の低い演算子）を読んだことにする
- コンパイラの論理的構造
  - 原始プログラムから目的プログラムまでに以下の処理を通る
    - 読み込み（行→文字）
    - 字句解析（文字→符）
    - 構文解析（符→構文木）
    - 中間語作成（構文木→中間語）
    - 最適化（中間語→機械語）
      - コンパイラにおける最適化とは、文字通りの最適化ではなく、最適なものに近づけるという意味
      - 最適化は中間語のレベルで行うだけでなく、構文木のレベルや、中間語から目的コードを生成する時、生成されたコードの列に対しても行われる
    - コード生成（機械語→目的プログラム）
      - Pascal などのように、主ルーチンからサブルーチンまで、そのプログラムの実行に必要なプログラムをすべてまとめてコンパイルする時
        - 目的プログラムと実行時ルーチンを結合して直ちに実行に入れる
      - C や Fortran などのように、主ルーチンやサブルーチンを別々にコンパイルする場合
        - 目的プログラムは別々のファイルに出力されることになる。それらをまとめて 1 つの実行可能なプログラムにするのは、リンカと呼ばれるソフトウェア
  - ただし、実際に作られるコンパイラは、必ずしもこの論理的構造通りにならない
- 実行効率をよくするために、最適化に重点を置いたコンパイラは最適化コンパイラと呼ばれる

## 3章: 文法と言語

- ALGOL60 は 1960 年にプログラム言語としては初めて国際的な組織で開発されたものであるが、その構文がバッカス記法によって定義されている。それ以来、多くのプログラム言語の構文規則はバッカス記法、またはそれを拡張した記法で記述されるようになった
- 末端に現れる記号を終端記号、それ以外のものを非終端記号と呼ぶ。またεは空を示す記号
- 構文規則を図式で表現したものを構文図式と呼ぶ
- 文脈自由文法 G は生成規則の集合 P と記号 S の組として定義される
  - G = {P, S}
  - S は開始記号または出発記号と呼ばれ、P の中の少なくとも 1 つの生成規則の左辺に現れていなければならない
- 文がどのような生成規則から生成されたか、構造を調べることを構文解析という。その結果得られた木は解析木と呼ばれる
- ある文の解析木が 2 通り以上存在すれば、その文はあいまいであるという。あいまいな文を生成できる文法をあいまい文法という

## 4章: 字句解析

- ここでは字句解析のプログラムを機械的に作り出す方法を解説
  - 字句の形は文脈自由文法よりも簡単な正規表現で定義できる
  - 字句の定義を正規表現で表現したものから、その字句を読み取る有限オートマトンを機械的に作成する方法を述べる
- 字句解析の流れ
  - 読み込んだ原始プログラムの中で最後に返した文字の位置を覚えていて
  - 呼ばれたら、その次の文字を返す。もし、返す文字がなかったらファイルから次のひとかたまりを読み込んで、その最初の文字を返す
- 本書では、字句解析の結果として得られる字句の内部表現のことをトークンまたは符と呼ぶ。字句読み取りのプログラムは、字句解析器や走査器とも呼ばれる
- オートマトン
  - 計算機の構造や動作を抽象化したモデルの 1 つ。内部に固有の状態と、状態を変化させる規則の集合を持ち、外部からの入力に応じて状態を変化させるもの
- 有限オートマトン（finite automaton）
  - 有限個の内部状態を持ち、与えられた記号列を読みながら状態遷移し、その記号列がある言語の文であるかどうかを判定するもの
- 非決定性有限オートマトン（nondeterministic finite automaton, NFA）と決定性有限オートマトン（deterministic finite automaton, DFA）
  - NFA は 1 つの入力記号に対して、複数個の状態遷移の可能性がある
  - DFA は複数の遷移の可能性がない。1 つに決まる
- DFA とは、以下の条件を満たす有限オートマトンである
  - εによる遷移がない
  - 1 つの状態から同じ記号による異なった状態への遷移はない
- DFA の作成方法。NFA に対応する DFA は以下の手順で作成できる
  - NFA の初期状態とその初期状態からε遷移で辿れるすべての状態からなる集合を DFA の初期状態とする (1)
  - 状態の集合からの遷移は、その集合の要素からの遷移の合併とする (2)
  - 上記 (2) を、新しい集合および遷移が得られなくなるまで繰り返す (3)
- 状態数最小化のアルゴリズム
  - 与えられた DFA の状態を、その最終状態からなる集合と、それ以外の状態の集合の 2 つの集合にわける (1)
  - 各集合を遷移の種類によって分割する。すなわち、その集合の要素 s, t からの遷移の種類が同じであれば同じ集合に入れ、そうでなければ別の集合に入れる (2)
  - 各集合を遷移先によって分割する。すなわち、その集合の要素 s, t から同じ記号による遷移で別の集合（この分割前の集合で）の要素に行くものがあれば、s と t を別々の集合に入れる (3)
  - (3) を繰り返して、どの集合もさらに分割できなくなったら終わる
- 最長一致と最短一致
  - 複数の分解方法が考えられる場合がある
  - できるだけ長い文字列を得ようとするのが最長一致、逆に短い文字列を得ようとするのが最短一致
  - 場合によって、適するものが違う

## 5章: 構文解析

- ここでは、まず構文解析の理論と実際の歴史を述べる。その後、構文解析の手法の代表的な 3 つを述べる
  - 再帰的下向き構文解析 / LR 構文解析 / 演算子順位構文解析
- これから読み込むものの形を先に仮定して、それに合致するかどうか調べていく構文解析法を「下向き構文解析法」と呼ぶ
  - その中で、構文解析のプログラムが再帰手続きで構成されるものを「再帰的下向き構文解析」と呼ぶ
  - 下向き構文解析法の問題点は後戻りと左再帰性
    - 後戻り: 探索の際、ある組み合わせが解でなかったなら、戻って別の組み合わせを試す。その組み合わせを試しても解でなかった場合、さらに探索木を戻り、新たな組み合わせを試すこと
    - 左再帰性: ある非終端記号を展開した結果、その先頭（最も左）にその非終端記号自身があらわれるような再帰のこと
- LL(1)文法
  - αまたはβのどちらかを選択する時、その時の入力の先頭記号を 1 つ見ることによって（後戻りの起こりえない）選択をできる文法
  - 一般に k 個の記号を見ることによってうまく選択できるような文法を LL(k)文法という。ただし、実際のコンパイラでは k = 1 以外が使われることはあまりない
- 集合の定義
  - First(α): αの先頭の終端記号になりうるものの集合
  - Follow(A): 文形式の中で A の直後の終端記号になりうるものの集合
  - Director(A,α): A をαに展開すべきか判定するための終端記号の集合
- 上向き構文解析法
  - 原始プログラムを左から右に走査しながら、還元できるものを順次還元していく方法。すでに解析をした結果はスタックに積んでおき、スタックの中に還元できるものがそろったら、それを還元しその結果で置き換えるという方法がとられる
  - シフトと還元の操作を適宜行う構文解析をシフト還元構文解析と呼ぶ
  - コンパイラで使われるシフト還元構文解析法は、各時点でシフトか還元か間違いなく決められるもので、後戻りなど必要ないもの。そのような構文解析法として、LR 構文解析法と演算子順位構文解析法がある
- シフト / 還元競合、あるいは還元 / 還元競合があると、そのどちらを実行すればよいか一般には決まらない。そこで 1 つ先読みをして、それがどの Follow 集合に入っているかによって動作を決められるのが SLR(1)文法
- SLR(1)文法では、競合を解決するのに Follow 集合だけを使っていたが、そこまでに読み込んでいた記号列も考慮するのが LR(1)文法
- LR(1)の状態の中で、同じ核の集合を持つものを合併して作るのが LALR(1)状態
- 演算子順位構文解析法
  - 演算子文法
    - 演算子文法では、右辺に非終端記号が複数個あるときは、必ずその間に終端記号が入る。その終端記号が演算子にあたる
  - 演算子順位文法
    - 演算子文法の任意の 2 個の終端記号の間に =, <, > のうちたかだか 1 個の関係しか成り立たないならば、この文法は演算子順位文法といえる
- 構文解析法の選択
  - 再帰的下向き構文解析
    - わかりやすい
    - 欠点は適用できる文法の範囲が比較的小さいことと、式の場合などの構文解析の効率が演算子順位に比べれば落ちる
  - LR 構文解析
    - 適用できる文法の範囲が広い
    - 欠点は、構文解析表を人手で作成するのは困難なので、自動生成するプログラムが必要
  - 演算子順位構文解析
    - 一般的なアルゴリズムでは必ずしも効率はよくないが、対象を式に限定すれば、一番効率が良い
    - 欠点は適用できる文法の範囲が比較的小さい
- ある構文解析を適用しようとして、そのまま適用できない場合の対策には、以下が考えられる
  - 意味情報を使う
  - 意味解析に任せる
  - より強力な構文解析法を使う
  - 複数パスで構文解析をする
  - 文法の書き方を変える
  - 言語を変える
- ある言語の構文規則を与えたら、その言語の構文解析器を生成するのが、構文解析器生成系

## 6章: 意味解析

- 意味解析を行うためには、宣言された情報をまとめておく必要があり、一般に表の形にまとめられる。ここでは記号表と呼ぶ
- 意味規則を形式的に記述する方法として、属性文法（attribute grammer）がある。属性文法は構文規則に意味規則を付加したもの
- 記号表
  - 記号表に入れる情報は一般に以下のようなもの（言語によって異なる）
    - 名前 / 型 / 記憶域 / その他
    - 記号表は、表の探索が効率良くできるように、一般には配列の形で実現される。記号表の中の各要素はエントリとも呼ばれる
  - 記号表に対する操作は、記号表に新しいエントリを書き込む操作（登録）と、ある名前が記号表に入っているかどうか探す操作（探索）とがある
  - 探索
    - 探索で各要素を順番に調べる操作を探針と呼び、平均して (n+1)/2 回の探索が必要になる。この探索は線形探索と呼ばれる
    - 速くする方法としては、二分探索とハッシュ法がある
      - 二分探索: 名前をその大きさの順に登録しておき、名前の大小比較によって次に探索する場所を決めていくもの
        - 探針の回数はほぼ [log2n]+1
        - n が大きい場合、探索の速度は線形探索よりずっと速くなるが、プログラムは少し複雑になる。登録操作が複雑になるのが欠点
      - ハッシュ法: 名前 x に対してある関数 f をほどこし、その結果の n=f(x) を使って表の第 n 番目を探すというもの
        - 除算法 / 平方採中法 / 折り返し法などがある
        - ハッシュ法で表を引くアルゴリズムは次のように表される
          - 名前 x からハッシュ関数 f を使って n=f(x) を求める
          - 表の第 n 番目を調べて
            - そこに x が入っていたら、x は登録されていた
            - そこに何も入っていなかったら、x は登録されていない
            - そこに x 以外のものが入っていたら、衝突
        - 衝突した場合の対応は大きく分けて、開番地法と連鎖法の 2 つがある
          - 開番地法: fi(i=1,2,...) と複数個のハッシュ関数を用意しておき、fi で衝突したら fi+1 を使う。これを衝突がなくなるまで繰り返す
          - 連鎖法: 衝突を起こしたものどうしをポインタでつなぐ方式。連鎖法には、連鎖の 2 つ目以降の名前を別領域に格納する方法もある（あふれハッシュ法）
          - どちらも一長一短あるが、初めから余裕を持って大きな表をとっておける場合は開番地法、そうでない場合はあふれハッシュ法がよい
        - ハッシュ表と記号表は分けたほうがよいことが多い
- 属性文法
  - 解析木の上から下に値が決まっていくのは相続属性と呼ばれる。反対に下から上に値が決まっていくのは合成属性と呼ばれる
  - 属性文法が与えられている時、G の任意の文の解析木に対して、その属性の評価を求めることができるプログラムが属性評価器
  - 与えられた属性文法 AG が、そのどんな文の解析木に対しても依存グラフがサイクルを持たないようなものである時、AG は非循環属性文法と呼ばれる
  - 解析木の上で依存グラフを重ねるのでなく、各生成規則の属性依存グラフをどのように重ねてもサイクルのない属性文法を絶対非循環属性文法という
    - 絶対非循環属性文法であれば、その属性評価器を作ることができる
  - 適用できる範囲があまり広くないが、効率のよい属性評価ができるクラスとして、構文解析と同時に属性評価ができるクラスがある
    - これらは、コンパイラの 1 つのパスで属性評価までできてしまうので、1 パス型の属性文法と呼ばれる
    - 1 パス型属性文法
      - S 属性文法
        - どの構文解析法とも組み合わせることができる
        - 合成属性だけを持ち、相続属性を持たない属性文法
      - L 属性文法
        - LL 構文解析法と組み合わせることができる
        - 属性文法において、任意の生成規則 X0→X1X2...Xn があるとする。任意の Xk(1<=k<=n) の相続属性が、X0 の相続属性と Xi(1<=i<=k-1) の合成属性だけに依存するもの
      - LR 属性文法
        - LR 構文解析法と組み合わせることができる
        - 属性文法が L 属性文法であり、その基底文脈自由文法のすべての LR 状態について、そこで必要な相続属性の値が求められるもの
