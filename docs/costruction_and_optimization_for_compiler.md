# 概要

## 本

- [コンパイラの構成と最適化 | 中田 育男](https://amzn.to/36jzadN)

## かかった時間

- x 時間

## 読む前の状態

- [コンピュータシステムの理論と実装](../docs/nand2tetris.md) でコンパイラの基礎は理解していた
- 「コンパイラの理論をもう少し深く知りたい」「最適化のところを知りたい」というモチベーションでやることにした

# 読書メモ

## 1章: はじめに

- コンパイラとは、高級プログラム言語で書かれたプログラムを、機械向き言語のプログラムに翻訳するためのプログラム
  - 機械向き言語には、仮想マシンの機械語も含む
- 原始プログラムのコンパイルから実行までに必要なすべてのシステムをあわせたものを言語処理系（または処理系）と呼ぶ

## 2章: コンパイラの簡単な例

- 記法の説明
  - 中置記法（a+b）
  - 前置記法（+ab）
    - ポーランド記法ともいう
  - 後置記法（ab+）
    - 逆ポーランド記法ともいう
- 後置記法の性質は、計算機で計算する時に都合がいい。計算機は後置記法の式の各項目を、並んでいる順番に計算すればいい
- 中置記法の式を後置記法に変換するアルゴリズム
  - スタックに左括弧（どの演算子よりも優先順位の低い演算子）を積む
  - 中置記法の式を左から読みながら
    - 演算数を読んだらそれをそのまま出力する（演算数:式が 1 つのもの。a とか）
    - 演算子を読んだら、スタックの上にそれより優先順位の高い演算子があればそれを（あるだけ順に）スタックから降ろして出力し、読んだ演算子をスタックに積む。ただし、式の終わりになったら、右括弧（どの演算子よりも優先順位の低い演算子）を読んだことにする
- コンパイラの論理的構造
  - 原始プログラムから目的プログラムまでに以下の処理を通る
    - 読み込み（行→文字）
    - 字句解析（文字→符）
    - 構文解析（符→構文木）
    - 中間語作成（構文木→中間語）
    - 最適化（中間語→機械語）
      - コンパイラにおける最適化とは、文字通りの最適化ではなく、最適なものに近づけるという意味
      - 最適化は中間語のレベルで行うだけでなく、構文木のレベルや、中間語から目的コードを生成する時、生成されたコードの列に対しても行われる
    - コード生成（機械語→目的プログラム）
      - Pascal などのように、主ルーチンからサブルーチンまで、そのプログラムの実行に必要なプログラムをすべてまとめてコンパイルする時
        - 目的プログラムと実行時ルーチンを結合して直ちに実行に入れる
      - C や Fortran などのように、主ルーチンやサブルーチンを別々にコンパイルする場合
        - 目的プログラムは別々のファイルに出力されることになる。それらをまとめて 1 つの実行可能なプログラムにするのは、リンカと呼ばれるソフトウェア
  - ただし、実際に作られるコンパイラは、必ずしもこの論理的構造通りにならない
- 実行効率をよくするために、最適化に重点を置いたコンパイラは最適化コンパイラと呼ばれる

## 3章: 文法と言語

- ALGOL60 は 1960 年にプログラム言語としては初めて国際的な組織で開発されたものであるが、その構文がバッカス記法によって定義されている。それ以来、多くのプログラム言語の構文規則はバッカス記法、またはそれを拡張した記法で記述されるようになった
- 末端に現れる記号を終端記号、それ以外のものを非終端記号と呼ぶ。またεは空を示す記号
- 構文規則を図式で表現したものを構文図式と呼ぶ
- 文脈自由文法 G は生成規則の集合 P と記号 S の組として定義される
  - G = {P, S}
  - S は開始記号または出発記号と呼ばれ、P の中の少なくとも 1 つの生成規則の左辺に現れていなければならない
- 文がどのような生成規則から生成されたか、構造を調べることを構文解析という。その結果得られた木は解析木と呼ばれる
- ある文の解析木が 2 通り以上存在すれば、その文はあいまいであるという。あいまいな文を生成できる文法をあいまい文法という

## 4章: 字句解析

- ここでは字句解析のプログラムを機械的に作り出す方法を解説
  - 字句の形は文脈自由文法よりも簡単な正規表現で定義できる
  - 字句の定義を正規表現で表現したものから、その字句を読み取る有限オートマトンを機械的に作成する方法を述べる
- 字句解析の流れ
  - 読み込んだ原始プログラムの中で最後に返した文字の位置を覚えていて
  - 呼ばれたら、その次の文字を返す。もし、返す文字がなかったらファイルから次のひとかたまりを読み込んで、その最初の文字を返す
- 本書では、字句解析の結果として得られる字句の内部表現のことをトークンまたは符と呼ぶ。字句読み取りのプログラムは、字句解析器や走査器とも呼ばれる
- オートマトン
  - 計算機の構造や動作を抽象化したモデルの 1 つ。内部に固有の状態と、状態を変化させる規則の集合を持ち、外部からの入力に応じて状態を変化させるもの
- 有限オートマトン（finite automaton）
  - 有限個の内部状態を持ち、与えられた記号列を読みながら状態遷移し、その記号列がある言語の文であるかどうかを判定するもの
- 非決定性有限オートマトン（nondeterministic finite automaton, NFA）と決定性有限オートマトン（deterministic finite automaton, DFA）
  - NFA は 1 つの入力記号に対して、複数個の状態遷移の可能性がある
  - DFA は複数の遷移の可能性がない。1 つに決まる
- DFA とは、以下の条件を満たす有限オートマトンである
  - εによる遷移がない
  - 1 つの状態から同じ記号による異なった状態への遷移はない
- DFA の作成方法。NFA に対応する DFA は以下の手順で作成できる
  - NFA の初期状態とその初期状態からε遷移で辿れるすべての状態からなる集合を DFA の初期状態とする (1)
  - 状態の集合からの遷移は、その集合の要素からの遷移の合併とする (2)
  - 上記 (2) を、新しい集合および遷移が得られなくなるまで繰り返す (3)
- 状態数最小化のアルゴリズム
  - 与えられた DFA の状態を、その最終状態からなる集合と、それ以外の状態の集合の 2 つの集合にわける (1)
  - 各集合を遷移の種類によって分割する。すなわち、その集合の要素 s, t からの遷移の種類が同じであれば同じ集合に入れ、そうでなければ別の集合に入れる (2)
  - 各集合を遷移先によって分割する。すなわち、その集合の要素 s, t から同じ記号による遷移で別の集合（この分割前の集合で）の要素に行くものがあれば、s と t を別々の集合に入れる (3)
  - (3) を繰り返して、どの集合もさらに分割できなくなったら終わる
- 最長一致と最短一致
  - 複数の分解方法が考えられる場合がある
  - できるだけ長い文字列を得ようとするのが最長一致、逆に短い文字列を得ようとするのが最短一致
  - 場合によって、適するものが違う

## 5章: 構文解析

- ここでは、まず構文解析の理論と実際の歴史を述べる。その後、構文解析の手法の代表的な 3 つを述べる
  - 再帰的下向き構文解析 / LR 構文解析 / 演算子順位構文解析
- これから読み込むものの形を先に仮定して、それに合致するかどうか調べていく構文解析法を「下向き構文解析法」と呼ぶ
  - その中で、構文解析のプログラムが再帰手続きで構成されるものを「再帰的下向き構文解析」と呼ぶ
  - 下向き構文解析法の問題点は後戻りと左再帰性
    - 後戻り: 探索の際、ある組み合わせが解でなかったなら、戻って別の組み合わせを試す。その組み合わせを試しても解でなかった場合、さらに探索木を戻り、新たな組み合わせを試すこと
    - 左再帰性: ある非終端記号を展開した結果、その先頭（最も左）にその非終端記号自身があらわれるような再帰のこと
- LL(1)文法
  - αまたはβのどちらかを選択する時、その時の入力の先頭記号を 1 つ見ることによって（後戻りの起こりえない）選択をできる文法
  - 一般に k 個の記号を見ることによってうまく選択できるような文法を LL(k)文法という。ただし、実際のコンパイラでは k = 1 以外が使われることはあまりない
- 集合の定義
  - First(α): αの先頭の終端記号になりうるものの集合
  - Follow(A): 文形式の中で A の直後の終端記号になりうるものの集合
  - Director(A,α): A をαに展開すべきか判定するための終端記号の集合
- 上向き構文解析法
  - 原始プログラムを左から右に走査しながら、還元できるものを順次還元していく方法。すでに解析をした結果はスタックに積んでおき、スタックの中に還元できるものがそろったら、それを還元しその結果で置き換えるという方法がとられる
  - シフトと還元の操作を適宜行う構文解析をシフト還元構文解析と呼ぶ
  - コンパイラで使われるシフト還元構文解析法は、各時点でシフトか還元か間違いなく決められるもので、後戻りなど必要ないもの。そのような構文解析法として、LR 構文解析法と演算子順位構文解析法がある
- シフト / 還元競合、あるいは還元 / 還元競合があると、そのどちらを実行すればよいか一般には決まらない。そこで 1 つ先読みをして、それがどの Follow 集合に入っているかによって動作を決められるのが SLR(1)文法
- SLR(1)文法では、競合を解決するのに Follow 集合だけを使っていたが、そこまでに読み込んでいた記号列も考慮するのが LR(1)文法
- LR(1)の状態の中で、同じ核の集合を持つものを合併して作るのが LALR(1)状態
- 演算子順位構文解析法
  - 演算子文法
    - 演算子文法では、右辺に非終端記号が複数個あるときは、必ずその間に終端記号が入る。その終端記号が演算子にあたる
  - 演算子順位文法
    - 演算子文法の任意の 2 個の終端記号の間に =, <, > のうちたかだか 1 個の関係しか成り立たないならば、この文法は演算子順位文法といえる
- 構文解析法の選択
  - 再帰的下向き構文解析
    - わかりやすい
    - 欠点は適用できる文法の範囲が比較的小さいことと、式の場合などの構文解析の効率が演算子順位に比べれば落ちる
  - LR 構文解析
    - 適用できる文法の範囲が広い
    - 欠点は、構文解析表を人手で作成するのは困難なので、自動生成するプログラムが必要
  - 演算子順位構文解析
    - 一般的なアルゴリズムでは必ずしも効率はよくないが、対象を式に限定すれば、一番効率が良い
    - 欠点は適用できる文法の範囲が比較的小さい
- ある構文解析を適用しようとして、そのまま適用できない場合の対策には、以下が考えられる
  - 意味情報を使う
  - 意味解析に任せる
  - より強力な構文解析法を使う
  - 複数パスで構文解析をする
  - 文法の書き方を変える
  - 言語を変える
- ある言語の構文規則を与えたら、その言語の構文解析器を生成するのが、構文解析器生成系
