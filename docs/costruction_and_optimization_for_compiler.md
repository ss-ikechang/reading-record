# 概要

## 本

- [コンパイラの構成と最適化 | 中田 育男](https://amzn.to/36jzadN)

## かかった時間

- x 時間

## 読む前の状態

- [コンピュータシステムの理論と実装](../docs/nand2tetris.md) でコンパイラの基礎は理解していた
- 「コンパイラの理論をもう少し深く知りたい」「最適化のところを知りたい」というモチベーションでやることにした

# 読書メモ

## 1章: はじめに

- コンパイラとは、高級プログラム言語で書かれたプログラムを、機械向き言語のプログラムに翻訳するためのプログラム
  - 機械向き言語には、仮想マシンの機械語も含む
- 原始プログラムのコンパイルから実行までに必要なすべてのシステムをあわせたものを言語処理系（または処理系）と呼ぶ

## 2章: コンパイラの簡単な例

- 記法の説明
  - 中置記法（a+b）
  - 前置記法（+ab）
    - ポーランド記法ともいう
  - 後置記法（ab+）
    - 逆ポーランド記法ともいう
- 後置記法の性質は、計算機で計算する時に都合がいい。計算機は後置記法の式の各項目を、並んでいる順番に計算すればいい
- 中置記法の式を後置記法に変換するアルゴリズム
  - スタックに左括弧（どの演算子よりも優先順位の低い演算子）を積む
  - 中置記法の式を左から読みながら
    - 演算数を読んだらそれをそのまま出力する（演算数:式が 1 つのもの。a とか）
    - 演算子を読んだら、スタックの上にそれより優先順位の高い演算子があればそれを（あるだけ順に）スタックから降ろして出力し、読んだ演算子をスタックに積む。ただし、式の終わりになったら、右括弧（どの演算子よりも優先順位の低い演算子）を読んだことにする
- コンパイラの論理的構造
  - 原始プログラムから目的プログラムまでに以下の処理を通る
    - 読み込み（行→文字）
    - 字句解析（文字→符）
    - 構文解析（符→構文木）
    - 中間語作成（構文木→中間語）
    - 最適化（中間語→機械語）
      - コンパイラにおける最適化とは、文字通りの最適化ではなく、最適なものに近づけるという意味
      - 最適化は中間語のレベルで行うだけでなく、構文木のレベルや、中間語から目的コードを生成する時、生成されたコードの列に対しても行われる
    - コード生成（機械語→目的プログラム）
      - Pascal などのように、主ルーチンからサブルーチンまで、そのプログラムの実行に必要なプログラムをすべてまとめてコンパイルする時
        - 目的プログラムと実行時ルーチンを結合して直ちに実行に入れる
      - C や Fortran などのように、主ルーチンやサブルーチンを別々にコンパイルする場合
        - 目的プログラムは別々のファイルに出力されることになる。それらをまとめて 1 つの実行可能なプログラムにするのは、リンカと呼ばれるソフトウェア
  - ただし、実際に作られるコンパイラは、必ずしもこの論理的構造通りにならない
- 実行効率をよくするために、最適化に重点を置いたコンパイラは最適化コンパイラと呼ばれる

## 3章: 文法と言語

- ALGOL60 は 1960 年にプログラム言語としては初めて国際的な組織で開発されたものであるが、その構文がバッカス記法によって定義されている。それ以来、多くのプログラム言語の構文規則はバッカス記法、またはそれを拡張した記法で記述されるようになった
- 末端に現れる記号を終端記号、それ以外のものを非終端記号と呼ぶ。またεは空を示す記号
- 構文規則を図式で表現したものを構文図式と呼ぶ
- 文脈自由文法 G は生成規則の集合 P と記号 S の組として定義される
  - G = {P, S}
  - S は開始記号または出発記号と呼ばれ、P の中の少なくとも 1 つの生成規則の左辺に現れていなければならない
- 文がどのような生成規則から生成されたか、構造を調べることを構文解析という。その結果得られた木は解析木と呼ばれる
- ある文の解析木が 2 通り以上存在すれば、その文はあいまいであるという。あいまいな文を生成できる文法をあいまい文法という

## 4章: 字句解析

- 字句解析の流れ
  - 読み込んだ原始プログラムの中で最後に返した文字の位置を覚えていて
  - 呼ばれたら、その次の文字を返す。もし、返す文字がなかったらファイルから次のひとかたまりを読み込んで、その最初の文字を返す
- 本書では、字句解析の結果として得られる字句の内部表現のことをトークンまたは符と呼ぶ。字句読み取りのプログラムは、字句解析器や走査器とも呼ばれる
- オートマトン
  - 計算機の構造や動作を抽象化したモデルの 1 つ。内部に固有の状態と、状態を変化させる規則の集合を持ち、外部からの入力に応じて状態を変化させるもの
- 有限オートマトン（finite automaton）
  - 有限個の内部状態を持ち、与えられた記号列を読みながら状態遷移し、その記号列がある言語の文であるかどうかを判定するもの
- 非決定性有限オートマトン（nondeterministic finite automaton, NFA）と決定性有限オートマトン（deterministic finite automaton, DFA）
  - NFA は 1 つの入力記号に対して、複数個の状態遷移の可能性がある
  - DFA は複数の遷移の可能性がない。1 つに決まる
- DFA とは、以下の条件を満たす有限オートマトンである
  - εによる遷移がない
  - 1 つの状態から同じ記号による異なった状態への遷移はない
- DFA の作成方法。NFA に対応する DFA は以下の手順で作成できる
  - NFA の初期状態とその初期状態からε遷移で辿れるすべての状態からなる集合を DFA の初期状態とする (1)
  - 状態の集合からの遷移は、その集合の要素からの遷移の合併とする (2)
  - 上記 (2) を、新しい集合および遷移が得られなくなるまで繰り返す (3)
- 状態数最小化のアルゴリズム
  - 与えられた DFA の状態を、その最終状態からなる集合と、それ以外の状態の集合の 2 つの集合にわける (1)
  - 各集合を遷移の種類によって分割する。すなわち、その集合の要素 s, t からの遷移の種類が同じであれば同じ集合に入れ、そうでなければ別の集合に入れる (2)
  - 各集合を遷移先によって分割する。すなわち、その集合の要素 s, t から同じ記号による遷移で別の集合（この分割前の集合で）の要素に行くものがあれば、s と t を別々の集合に入れる (3)
  - (3) を繰り返して、どの集合もさらに分割できなくなったら終わる
- 最長一致と最短一致
  - 複数の分解方法が考えられる場合がある
  - できるだけ長い文字列を得ようとするのが最長一致、逆に短い文字列を得ようとするのが最短一致
  - 場合によって、適するものが違う
