# 概要

## 本

- [作って理解するOS x86系コンピュータを動かす理論と実装 | 林 高勲, 川合 秀実](https://amzn.to/36I8Ry7)

## かかった時間

- x 時間

## 読む前の状態

- OS についての本は何も読んでいなく、1 冊目として手を動かしながら概要を抑えるために読み始めた
- CPU やコンパイラについては、基本は理解している状態
  - [コンピュータシステムの理論と実装](./nand2tetris.md)
  - [CPUの創りかた](./how_to_create_cpu.md)
  - [プロセッサを支える技術](./technologies_for_processors.md)
  - [コンパイラの構成と最適化](./costruction_and_optimization_for_compiler.md)

## 読む前後の変化

- xxx

# 読書メモ

## イントロダクション

- アドレスとポインタ
  - C 言語では、型情報を含んだアドレスのことをポインタと呼び、単なるアドレスとは区別している
    - アドレス: メモリの位置
    - ポインタ: メモリの位置と型情報
  - 間接演算子（*）はポインタが示す変数を表す
  - アドレス演算子（&）は変数のポインタを取得する

## 1章: コンピュータの基礎を理解する

- デューティ比: 1 つの周期内で電圧が高い割合
- イネーブル信号
  - コンピュータの内部には、特定の役割を持った回路がいくつも存在している
  - これらの回路は結果の出力先が同じなので、データを出力する信号線を共有している
  - このため、必要となる回路の出力だけを正しいタイミングで取り出さなくてはならない
  - これを実現するために、多くの回路には、機能や出力信号をアクティブにするためのイネーブル信号が用意されている
  - イネーブル信号は回路からの出力を許可するための信号
- 結線により行うプログラミング方式をワイヤードプログラミング方式という。物理的な変更を必要としない、書き換え可能なメモリにプログラムを記録する方式をストアドプログラミング方式という
- タスク: OS が管理する一連の処理
  - 一般的にジョブは連続処理、タスクは並列処理が行われる時に使用される概念
- タスク切り換え
  - 複数音タスクを切り替えるのは OS の役割
  - タスクが使用する領域は、CPU 内のレジスタとメモリ上のデータ領域に大別される
  - メモリ上のデータ領域は OS がタスクごとに提供するので、他のタスクとの競合を考慮する必要はない。しかし、CPU 内のレジスタはすべてのタスクで共有されるので、タスクごとに個別に管理する必要がある
    - この時、タスクが使用するすべてのレジスタのことをコンテキストという

## 2章: ソフトウェアの基礎

- チューリングマシン
  - アラン・チューリングによって発表された概念的な計算装置のこと
  - チューリングマシンはあらかじめ定義された状態のみを遷移するステートマシンで、その状態は現在の状態と入力された値によってのみ変化する
- OS の主な役割
  - リソース管理
    - OS は接続されたすべてのデバイスをリソースとして管理する。タスクは、OS が管理しないリソースを利用することはできない
    - OS が管理するリソースには、各プロセスによって使用される仮想的なリソースも含まれる。代表的なものが CPU 時間
  - プロセス管理
    - OS が管理するプログラムの実行単位をプロセスという
    - OS はプロセスを管理し、適切な権限を持つプロセスだけが制限されたリソースにアクセスできるようにする
  - インタフェースの管理
    - ソフトウェア / ハードウェアインタフェースは、プロセスが利用可能なリソースにアクセスするための共通インタフェースとなる
    - OS はこれらを管理することで、プロセスに対して、共通のインタフェースを提供する
- プロセスとは何か
  - インスタンス
    - メモリ上に展開された「プログラム」はプログラムの実行状態、またはインスタンスと呼ばれる
    - インスタンスはコード（プログラム）/ データ（実行状態）/ コンテキスト（レジスタ値）を含む
  - プロセスの役割
    - インスタンスごとの状態を管理するのがプロセスの役割
    - プロセスはインスタンスに加え、OS 管理情報（権限）を含む
  - プロセスの状態遷移
    - プロセスはそれぞれ、生成 / 待機 / 実行 / ブロック / 終了のうち、1 つの状態を取る
  - プロセスの実行
    - OS はメモリ上に展開された待機状態のプロセスの中から、実行状態へと移行させるプロセスを 1 つだけ選び出す。どのプロセスを選択するかは、OS の性能や使いやすさに直結する作業で、スケジューリングと呼ばれる
    - 実行状態に移行したプロセスは、OS から割り当てられた時間しか実行状態でいることができない。この時間のことをクォンタムという
    - ほとんどの OS は、クォンタムを使い切ったプロセスを定期的に切り替える方式を採用しているが、このような方式はプリエンプティブ（Preemptive: 先取権のある）なマルチタスクと呼ばれる
    - これに対して、それぞれのプロセスが自発的に他のプロセスに実行権を譲る方式は、ノンプリエンプティブまたは協調型マルチタスクと呼ばれる
- カーネルとは何か
  - OS の中心的な機能を持ったプログラムまたはその集まりのことをカーネルという
  - CPU は特権モードと非特権モードの 2 つの動作モードを持つ
    - 特権モードでは、すべての CPU 命令を使用できる
    - 非特権モードでは、一部の命令を使用できない
  - OS はリソースに対するアクセス方法として、システムコールと呼ばれるインタフェースを用意している
    - タスクは、OS により動作が厳密に定義されたシステムコールを介してのみ、リソースへのアクセスが許可される
  - カーネルの種別
    - カーネル自体を小さく保つ設計をマイクロカーネルと呼ぶ
    - マイクロカーネルに対して、すべての機能を OS 本体に含む設計をモノリシックカーネルと呼ぶ
- 同期処理の必要性とその実現方法
  - 以下のような実現方法がある
    - ソフトウェアで実現する: デッカーのアルゴリズム
    - ハードウェアで実現する: テストアンドセット
    - ハードウェア + OS で実現する: セマフォ
  - ビジーウェイト: 変数の値が変化することを検査するだけのために CPU 時間を使っている期間
  - デッカーのアルゴリズム
    - 交互実行を必要としない同期処理ができる。共有メモリによる通信のみで、2 つのプロセスが 1 つのリソースを競合することなく共有できる
    - 欠点
      - プロセスが多くなった場合、それぞれのプロセスが互いに他のプロセスを認識する必要があり、プロセスの数だけグローバル変数が必要
      - 各プロセスが次に動作するプロセスを指定する必要もある
      - それぞれのプロセスが他のプロセスの変数を参照することになるので、プロセスの独立性も下がる
      - 静的な変数を参照するので、動的に生成または終了したプロセスを考慮していない
  - テストアンドセット
    - あるメモリ位置へアトミックに書き込みを行うコンピュータの命令
    - 共有変数の「値の確認と更新」を 1 つの命令で行う（CPU がメモリアクセス時にロック信号を出力する）
      - 分割されない一連の処理をアトミック処理という
    - ただし、これでもビジーウェイトの問題は残ったまま
      - ビジーウェイト中のプロセスは、実行状態に移行したとしてもリソースの解放を確認するだけなので、コンテキストの切り替えさえも行いたくない
  - セマフォ
    - P 命令と V 命令によってのみ値が変更される整数型変数 S を用いた同期処理
    - グローバル変数 S に初期値として設定された値は、クリティカルセクションを同時に実行できるプロセス数となる
    - リソースの解放を待つだけのプロセスをブロック状態に遷移させるので、ビジーウェイトを取り除くことができる
- デッドロックの発生要因とその回避方法
  - あるプロセスが解放される見込みのないリソースを待ち続けている状態をデッドロックという
  - デッドロックが発生する条件は以下の 4 つと言われる。これらの条件がすべて揃うとデッドロックが発生する可能性があり、条件が 1 つでも欠ければデッドロックを回避できる
    - 排他制御状態
      - リソースの取得に対して、排他的なアクセス制御が行われている
    - 保有待機状態
      - リソースを保有しているプロセスが新しいリソースを要求できる
    - 優先取得権のない状態
      - プロセスが保有しているリソースを強制的に取り上げることができない
    - 循環待機状態
      - 複数のプロセスが、異なる順序での複数のリソースを要求できる
- スケジューリング
  - OS はプロセスが使用する CPU の使用効率を高めながらも適切な応答速度を維持し、より多くのプロセスを並行して実行することが求められる
  - これらを考慮し、次に実行すべきプロセスを決定することをスケジューリングという
  - ターンアラウンド: プロセスの実行が要求されてから、終了するまでの時間
  - リアルタイム: 決められた許容範囲内で処理が終了すること
