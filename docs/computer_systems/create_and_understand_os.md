# 概要

## 本

- [作って理解するOS x86系コンピュータを動かす理論と実装 | 林 高勲, 川合 秀実](https://amzn.to/36I8Ry7)

## かかった時間

- x 時間

## 読む前の状態

- OS についての本は何も読んでいなく、1 冊目として手を動かしながら概要を抑えるために読み始めた
- CPU やコンパイラについては、基本は理解している状態
  - [コンピュータシステムの理論と実装](./nand2tetris.md)
  - [CPUの創りかた](./how_to_create_cpu.md)
  - [プロセッサを支える技術](./technologies_for_processors.md)
  - [コンパイラの構成と最適化](./costruction_and_optimization_for_compiler.md)

## 読む前後の変化

- xxx

# 読書メモ

## イントロダクション

- アドレスとポインタ
  - C 言語では、型情報を含んだアドレスのことをポインタと呼び、単なるアドレスとは区別している
    - アドレス: メモリの位置
    - ポインタ: メモリの位置と型情報
  - 間接演算子（*）はポインタが示す変数を表す
  - アドレス演算子（&）は変数のポインタを取得する

## 1章: コンピュータの基礎を理解する

- デューティ比: 1 つの周期内で電圧が高い割合
- イネーブル信号
  - コンピュータの内部には、特定の役割を持った回路がいくつも存在している
  - これらの回路は結果の出力先が同じなので、データを出力する信号線を共有している
  - このため、必要となる回路の出力だけを正しいタイミングで取り出さなくてはならない
  - これを実現するために、多くの回路には、機能や出力信号をアクティブにするためのイネーブル信号が用意されている
  - イネーブル信号は回路からの出力を許可するための信号
- 結線により行うプログラミング方式をワイヤードプログラミング方式という。物理的な変更を必要としない、書き換え可能なメモリにプログラムを記録する方式をストアドプログラミング方式という
- タスク: OS が管理する一連の処理
  - 一般的にジョブは連続処理、タスクは並列処理が行われる時に使用される概念
- タスク切り換え
  - 複数音タスクを切り替えるのは OS の役割
  - タスクが使用する領域は、CPU 内のレジスタとメモリ上のデータ領域に大別される
  - メモリ上のデータ領域は OS がタスクごとに提供するので、他のタスクとの競合を考慮する必要はない。しかし、CPU 内のレジスタはすべてのタスクで共有されるので、タスクごとに個別に管理する必要がある
    - この時、タスクが使用するすべてのレジスタのことをコンテキストという

## 2章: ソフトウェアの基礎

- チューリングマシン
  - アラン・チューリングによって発表された概念的な計算装置のこと
  - チューリングマシンはあらかじめ定義された状態のみを遷移するステートマシンで、その状態は現在の状態と入力された値によってのみ変化する
- OS の主な役割
  - リソース管理
    - OS は接続されたすべてのデバイスをリソースとして管理する。タスクは、OS が管理しないリソースを利用することはできない
    - OS が管理するリソースには、各プロセスによって使用される仮想的なリソースも含まれる。代表的なものが CPU 時間
  - プロセス管理
    - OS が管理するプログラムの実行単位をプロセスという
    - OS はプロセスを管理し、適切な権限を持つプロセスだけが制限されたリソースにアクセスできるようにする
  - インタフェースの管理
    - ソフトウェア / ハードウェアインタフェースは、プロセスが利用可能なリソースにアクセスするための共通インタフェースとなる
    - OS はこれらを管理することで、プロセスに対して、共通のインタフェースを提供する
- プロセスとは何か
  - インスタンス
    - メモリ上に展開された「プログラム」はプログラムの実行状態、またはインスタンスと呼ばれる
    - インスタンスはコード（プログラム）/ データ（実行状態）/ コンテキスト（レジスタ値）を含む
  - プロセスの役割
    - インスタンスごとの状態を管理するのがプロセスの役割
    - プロセスはインスタンスに加え、OS 管理情報（権限）を含む
  - プロセスの状態遷移
    - プロセスはそれぞれ、生成 / 待機 / 実行 / ブロック / 終了のうち、1 つの状態を取る
  - プロセスの実行
    - OS はメモリ上に展開された待機状態のプロセスの中から、実行状態へと移行させるプロセスを 1 つだけ選び出す。どのプロセスを選択するかは、OS の性能や使いやすさに直結する作業で、スケジューリングと呼ばれる
    - 実行状態に移行したプロセスは、OS から割り当てられた時間しか実行状態でいることができない。この時間のことをクォンタムという
    - ほとんどの OS は、クォンタムを使い切ったプロセスを定期的に切り替える方式を採用しているが、このような方式はプリエンプティブ（Preemptive: 先取権のある）なマルチタスクと呼ばれる
    - これに対して、それぞれのプロセスが自発的に他のプロセスに実行権を譲る方式は、ノンプリエンプティブまたは協調型マルチタスクと呼ばれる
- カーネルとは何か
  - OS の中心的な機能を持ったプログラムまたはその集まりのことをカーネルという
  - CPU は特権モードと非特権モードの 2 つの動作モードを持つ
    - 特権モードでは、すべての CPU 命令を使用できる
    - 非特権モードでは、一部の命令を使用できない
  - OS はリソースに対するアクセス方法として、システムコールと呼ばれるインタフェースを用意している
    - タスクは、OS により動作が厳密に定義されたシステムコールを介してのみ、リソースへのアクセスが許可される
  - カーネルの種別
    - カーネル自体を小さく保つ設計をマイクロカーネルと呼ぶ
    - マイクロカーネルに対して、すべての機能を OS 本体に含む設計をモノリシックカーネルと呼ぶ
- 同期処理の必要性とその実現方法
  - 以下のような実現方法がある
    - ソフトウェアで実現する: デッカーのアルゴリズム
    - ハードウェアで実現する: テストアンドセット
    - ハードウェア + OS で実現する: セマフォ
  - ビジーウェイト: 変数の値が変化することを検査するだけのために CPU 時間を使っている期間
  - デッカーのアルゴリズム
    - 交互実行を必要としない同期処理ができる。共有メモリによる通信のみで、2 つのプロセスが 1 つのリソースを競合することなく共有できる
    - 欠点
      - プロセスが多くなった場合、それぞれのプロセスが互いに他のプロセスを認識する必要があり、プロセスの数だけグローバル変数が必要
      - 各プロセスが次に動作するプロセスを指定する必要もある
      - それぞれのプロセスが他のプロセスの変数を参照することになるので、プロセスの独立性も下がる
      - 静的な変数を参照するので、動的に生成または終了したプロセスを考慮していない
  - テストアンドセット
    - あるメモリ位置へアトミックに書き込みを行うコンピュータの命令
    - 共有変数の「値の確認と更新」を 1 つの命令で行う（CPU がメモリアクセス時にロック信号を出力する）
      - 分割されない一連の処理をアトミック処理という
    - ただし、これでもビジーウェイトの問題は残ったまま
      - ビジーウェイト中のプロセスは、実行状態に移行したとしてもリソースの解放を確認するだけなので、コンテキストの切り替えさえも行いたくない
  - セマフォ
    - P 命令と V 命令によってのみ値が変更される整数型変数 S を用いた同期処理
    - グローバル変数 S に初期値として設定された値は、クリティカルセクションを同時に実行できるプロセス数となる
    - リソースの解放を待つだけのプロセスをブロック状態に遷移させるので、ビジーウェイトを取り除くことができる
- デッドロックの発生要因とその回避方法
  - あるプロセスが解放される見込みのないリソースを待ち続けている状態をデッドロックという
  - デッドロックが発生する条件は以下の 4 つと言われる。これらの条件がすべて揃うとデッドロックが発生する可能性があり、条件が 1 つでも欠ければデッドロックを回避できる
    - 排他制御状態
      - リソースの取得に対して、排他的なアクセス制御が行われている
    - 保有待機状態
      - リソースを保有しているプロセスが新しいリソースを要求できる
    - 優先取得権のない状態
      - プロセスが保有しているリソースを強制的に取り上げることができない
    - 循環待機状態
      - 複数のプロセスが、異なる順序での複数のリソースを要求できる
- スケジューリング
  - OS はプロセスが使用する CPU の使用効率を高めながらも適切な応答速度を維持し、より多くのプロセスを並行して実行することが求められる
  - これらを考慮し、次に実行すべきプロセスを決定することをスケジューリングという
  - ターンアラウンド: プロセスの実行が要求されてから、終了するまでの時間
  - リアルタイム: 決められた許容範囲内で処理が終了すること

## 3章: メモリ管理のしくみ

- ROM
  - ROM は特殊な処理で書き込みも可能。ユーザーがプログラムを書き込むことができる ROM のことを PROM（Programmable ROM）という
  - 消去可能なもの
    - EPROM（Erasable PROM）
      - 消去可能な ROM
      - チップの表面に紫外線を十分に当てると、データの消去が行える
    - EEPROM（Electrically Erasable PROM）
      - 電気的にデータを消去可能
    - Flash ROM
      - 基板上で使用する電圧を使い、データの消去および書き込みが可能（通常の PROM は普段の動作時に使用される以上の高い電圧を必要としていた）
  - 消去不可能なもの
    - OTPROM（One Time PROM）
      - ユーザーが一度だけ書き込みができる PROM
    - Mask ROM
      - 工場の製造段階で一度だけ書き込みができる PROM
- RAM
  - データを保持する方法により DRAM（Dynamic RAM）と SRAM（Static RAM）に分類される
  - DRAM はコンデンサを使ってデータを保持するので、リフレッシュを行う必要がある
  - SRAM はコンデンサではなく、複数の回路を使ってデータを保持するもの。リフレッシュが不要となる反面、回路が複雑になるので、アクセス速度や容量では DRAM より劣ることになる。同量の DRAM よりも高価になる傾向がある
- セクション
  - プログラムはその内容により、セクションという単位でまとめられている
  - 大きく分けて、プログラム / 定数 / 初期化 / 未初期化の 4 つのセクションに分類される
- メモリを効率的に利用する手法
  - オーバーレイ
    - メモリに入りきらないプログラムコードを必要なときにだけロードして使用する方法
    - OS にはプログラムの先頭部分だけをロードしてもらい、残りの部分はプロセス自身でメモリにロードする
  - バンク切り替え
    - CPU のアドレス信号を増やすことなく、アクセス可能なメモリ容量を拡張する手法
    - アドレス信号に変わり、多くの場合、ポート出力信号が利用される
    - 切り替えが行われるメモリ領域のことをバンク領域と呼び、ポート出力の値により、異なる実メモリが割り当てられる
  - プロセスのロード
    - 複数のプロセスをメモリに展開する場合、重複しない領域を割り当てるが、効率的にメモリを利用できるように配置する必要がある
    - メモリサイズによるロード
      - メモリ全体をいくつかの領域に分割し、その 1 つ 1 つにプロセスを展開する方法
    - プロセスサイズによるロード
      - プロセスが要求するメモリ領域は可変であるため、空いているメモリ領域に隙間なくプロセスを割り当てていけば未使用領域が生成されず、メモリを効率的に使用できる
      - しかしこれは最初だけで、プロセスの起動と終了が繰り返し行われる過程で十分なメモリ領域があるにも関わらず、メモリ領域が連続していないためプロセスを起動できない状態が発生する
    - プロセスの入れ替え
      - スワップアウト: メモリ上のプロセス全体を外部記憶装置に移動すること
      - スワップイン: 外部記憶装置にあるプロセスイメージをメモリ上に移動すること
      - スワップアウトで作成される、外部記憶装置上のファイルはスワップファイルと呼ばれる
- 論理アドレスと物理アドレス
  - すべてのプロセスは異なるメモリ領域に展開されるので、それぞれ異なるデータ領域にアクセスする必要がある
  - これは、プログラムごとの相対的なアドレス指定にプロセスごとのベースアドレスを追加することで対応する
  - OS とプロセスの双方でメモリのアクセス位置を調整する方法
    - OS はプロセスごとのメモリ領域を管理し、プロセスは OS から割り当てられた領域だけにアクセス範囲を限定する
  - プロセスがアクセスするメモリ領域が重ならないように、OS がアドレスを変換する方法
    - OS はプロセスがアクセスしようとしたアドレス（論理アドレス）と、OS により変換されたアドレス（物理アドレス）の 2 種類のアドレスを管理する
    - すべてのアドレス変換をソフトウェアである OS が行うのはとても負荷がかかるので、現実的ではない
- MMU（Memory Management Unit）
  - アドレス変換を含め、メモリ管理に関する制御を専門に行うハードウェアは MMU と呼ばれる
  - MMU がアドレス変換を行う範囲のことをページという。また、アドレス変換がページ単位で行われることから、ページ変換とも呼ばれる
- ページテーブル
  - ページ変換は MMU が行うが、正しく変換されるように設定するのは OS の仕事
  - OS はプロセスごとにアドレス変換を行うためのページテーブルを作成して管理する
    - ページテーブルには、ページごとの変換情報などが格納される
  - OS は MMU のページ変換機能により、プロセスごとに異なるアドレス空間を提供できる
    - 重要なポイントは 2 つ
      - すべての論理アドレスにページ変換を適用できる
      - プロセスごとにページ変換テーブルを用意できる
- 仮想メモリ
  - 外部記憶装置をページイメージの一時的な保存領域として使用するメモリ管理技法のこと
  - メモリに空き領域がない状態で、ページフォルトが発生すると、OS はメモリ上に空き領域を確保しようとする。使用中のページから使用頻度の低いいくつかのページを選択し、外部記憶装置に保存する。これをページアウトという
  - ページアウトと反対に、外部記憶装置からページデータをメモリにコピーすることをページインと呼ぶ
- セグメンテーション
  - 1 つのプロセスが複数のアドレス空間を利用できる機能。このときにプロセスが利用する論理的なアドレス空間をセグメントという
