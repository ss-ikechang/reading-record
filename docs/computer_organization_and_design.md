# 概要

## 本

- [コンピュータの構成と設計 第5版 上・下電子合本版 | デイビッド・A・パターソン, 成田 光彰](https://amzn.to/2Wj7mSc)

## かかった時間

- x 時間

## 読む前の状態

- [コンピュータシステムの理論と実装](../docs/nand2tetris.md) と [プロセッサを支える技術](../docs/technologies_for_processors.md) と [CPUの創りかた](../docs/how_to_create_cpu.md) を読んでいた
- 「プロセッサを支える技術」である程度、CPU でどのような技術が使われているか学習していたが、もう少し深い内容がありそうだったのと、演習があったので理解を確認するためにこの本をやることにした

# 読書メモ

## 1章: コンピュータの抽象化とテクノロジ

- コンピュータの利用形態は下記の 3 通り
  - パーソナル・コンピュータ: 個人が使用するように設計されたコンピュータ
    - 単一のユーザーに低いコストで高い性能を提供することに重点が置かれたもの
  - サーバー: 複数ユーザーを対象として大規模なプログラムを実行するために使用するコンピュータ
    - かつての大型コンピュータが新たに形を変えたものであり、通常はネットワークを通じてのみアクセスされる。大量の仕事をこなすことに特化している
    - またスーパーコンピュータ（性能とコストが最高レベルのコンピュータ）もサーバーとして構成される
  - 組み込みコンピュータ: 単一の専用アプリケーションまたはソフトウェア群を実行するために、他の装置の内部に組み込まれて使用されるコンピュータ
    - 自動車に搭載されるマイクロプロセッサ、テレビ内のコンピュータなど。組み込み用途における要求は、性能は最小限でよいがコストや消費電力は厳しく抑えたいという、独特の組み合わせであることが多い
- 本書で学べること
  - 優秀なプログラマは絶えず自分が作成するプログラムの性能に注意を払う
  - 1960 年代および 1970 年代においては、コンピュータの性能に対する主な制約要因はメモリの容量
  - 現在ではメモリ容量はほとんど制約にならなくなったが、代わりにプロセッサの並列性や記憶の階層性などについて理解する必要がでてきた
  - そのうえ、PMD（Personal Mobile Device）またはクラウドの上で実行されるプログラムのエネルギー効率について、配慮する必要がある
- コンピュータ・アーキテクチャにおける 8 つの主要なアイデア
  - Moore の法則の設計
  - 設計を単純化するための、抽象化
  - 一般的な場合を高速化する
  - 並列処理による性能向上
  - パイプライン処理による性能向上
  - 予測による性能向上
  - 記憶階層
  - 冗長性による信頼性向上
- オペレーティング・システムで重要なのは以下の機能
  - 基本的な入出力処理を行う
  - 外部記憶およびメモリを割り当てる
  - コンピュータを同時に使用する複数のアプリケーションの間で、コンピュータ資源の共有を図る
- コンピュータの古典的な 5 つの構成要素は、入力・出力・記憶・データパス・制御である。データパスと制御をあわせてプロセッサと呼ぶこともある
- コンピュータをネットワークに接続すれば、下記の利点が得られる
  - 通信: コンピュータ間で情報を高速に交換できる
  - 資源の共有: 個々のコンピュータがそれぞれ独自の入出力を備えるのではなく、ネットワークを通じて複数のコンピュータで入力を共有できる
  - リモート・アクセス: 遠隔地のコンピュータ同士をつなぐことによって、ユーザーは自分のコンピュータのそばにいなくてもよくなる
- チップの製造はシリコンから始まり、シリコン中の小さな領域に下記の 3 つの性質のいずれかを持たせることができる
  - 電気をよく通す
  - 電気を絶縁する
  - 特定の条件に応じて電気を通したり、絶縁したりする（スイッチの役割をする）
- PMD では応答時間が重視され、サーバーではスループットが重視される。性能を比較する上で、まず性能を定義する必要がある
- 性能に関する用語
  - 応答時間: タスクの完了に要した合計時間であり、ディスク・アクセス、メモリ・アクセス、入出力動作、オペレーティング・システムのオーバーヘッドなどのすべてを含む
  - CPU 時間: 該当プログラムのために CPU が費やした時間であり、入出力待ち時間や他のプログラムを実行させるための時間を含まない
    - CPU 時間はさらに 2 つに分けられる
      - ユーザー CPU 時間: プログラム中で費やされた CPU 時間
      - システム CPU 時間: プログラムに代わって、オペレーティング・システムがタスクを遂行するために費やした CPU 時間
  - この本では、他に負荷のかかっていないシステム上での経過時間を指してシステム性能という用語を使用し、ユーザー CPU 時間を指して CPU 性能という用語を使用する
- CPU 性能とその要因
  - 「あるプログラムの CPU 実行時間」=「そのプログラムの CPU クロック・サイクル数」\*「クロック・サイクル時間」
  - 「CPU クロック・サイクル数」=「プログラムの実行命令数」\*「命令当たりの平均クロック・サイクル数」
  - 「命令当たりの平均クロック・サイクル数」は CPI（clock cycle per instruction）とも言う
  - 「あるプログラムの CPU 実行時間」=「実行命令数」\*「CPI」\*「クロック・サイクル時間」とも書ける
  - コンピュータの性能を表す完全かつ信頼性のある唯一の尺度は時間であることを、常に念頭に置く
- CPI は 1 より小さくなる場合もある（1 サイクルに複数命令を実行する場合）
- 電力の壁
  - エネルギーは「容量性負荷 \* 電圧の 2 乗」に比例する
  - 消費電力は「1/2 \* 容量性負荷 \* 電圧の 2 乗 \* 切り替え周波数」に比例する
- コンピュータの性能測定を目的としたプログラムをベンチマークと呼ぶ
- 誤信と落とし穴
  - 落とし穴
    - コンピュータのある面を改善することによって、その改善度に等しい性能向上を期待すること
      - 改善の影響を受けないものもある（参考: Amdahl の法則）
    - 性能の尺度に性能方程式の一部を使用すること
  - 誤信
    - コンピュータの利用率が低ければ、消費電力は少ない
      - 負荷が 10％でもピーク時の 33％の電力を使用していたりするので、利用率が低いときの電力効率は重要
    - 性能を上げる設計とエネルギー効率を上げる設計とは、目標的に無関係である

## 2章: 命令:コンピュータの言葉

- ハードウェアの設計原則 3 つ
  - 単純性は規則性につながる
  - 小さければ小さいほど高速になる
  - 優れた設計には適度な妥協が必要である
- 各レジスタの役割
  - フレームポインタ: 手続きフレームの先頭の語を示す
    - 手続きフレーム: スタックのうち、手続きによって退避されたレジスタおよびローカル変数が収められている領域

| 名前    | レジスタ番号 | 用途                         | 呼び出し時に退避？ |
|---------|--------------|------------------------------|--------------------|
| $zero   | 0            | 定数値ゼロ                   | 該当せず           |
| \$v0-$v1 | 2-3          | 結果および式の評価のための値 | no                 |
| \$a0-$a3 | 4-7          | 引数                         | no                 |
| \$t0-$t7 | 8-15         | 一時                         | no                 |
| \$s0-$s7 | 16-23        | 退避（変数に対応）           | yes                |
| \$t8-$t9 | 24-25        | 予備の一時                   | no                 |
| $gp     | 28           | グローバルポインタ           | yes                |
| $sp     | 29           | スタックポインタ             | yes                |
| $fp     | 30           | フレームポインタ             | yes                |
| $ra     | 31           | 戻りアドレス                 | yes                |

- MIPS では語のアドレスは 4 の倍数でなければならない。これを整列化制約と呼ぶ
- コンパイラは頻繁に使用する変数をレジスタに保持しておき、それ以外の変数をメモリに置こうとする。使用頻度の低い変数をメモリ上に置くことをスピルアウトという
- オペランドが定数となるケースは頻繁に発生するので、定数を算術演算命令に含めている（addi など）
- MIPS のフィールド
  - R 形式（レジスタ用）
    - op: 命令の基本操作、従来から命令操作コードと呼ばれている。6 ビット
    - rs: 第 1 のソース・オペランドのレジスタ。5 ビット
    - rt: 第 2 のソース・オペランドのレジスタ。5 ビット
    - rd: デスティネーション・オペランドのレジスタ。結果を収める先。5 ビット
    - shamt: シフト量。5 ビット
    - funct: 機能。命令操作フィールドのバリエーションを表す。機能コードと呼ばれることもある。6 ビット
  - I 形式（即値およびデータ転送命令用）の場合は op / rs / rt と 16 ビットの constant または address
  - J 形式
- プログラム内蔵方式は以下の 2 つの基本原理から生まれた
  - 命令は数値として表現される
  - プログラムをメモリ中に格納して、データと同様に読み書きできる
- ヒープ領域（データ構造のヒープの意味とは異なる）
  - コンピュータプログラムが実行時に使用するメモリ領域の 1 つで、動的に確保や解放を繰り返せるもの
- ASCII コードでは 1 文字を 8 ビットで表す。Unicode では通常 16 ビットで 1 文字を表す
- MIPS のアドレシングモード
  - 即値アドレシング: 命令中に指定した定数をオペランドとする
  - レジスタ・アドレシング: オペランドにレジスタをとる
  - ベース相対アドレシング: 命令中に指定した定数とレジスタの和によって、オペランドが記憶されているメモリの位置を示す
  - PC 相対アドレシング: PC と命令中に指定した定数との和によってアドレスを示す。16 ビットのアドレスを 2 ビット左にシフトして、PC と加算する
  - 疑似直接アドレシング: 命令中の 26 ビットと PC の上位ビットを連結したものがジャンプアドレスとなる。26 ビットのアドレスを 2 ビット左にシフトして、PC の上位 4 ビットと連結する

# 解答メモ

## 1章

### 1.1

- パーソナル・コンピュータ: 個人が使用するように設計されたコンピュータ。通常はグラフィック・ディスプレイ、キーボード、マウスを備えている
- サーバー: 複数ユーザーを対象として大規模なプログラムを実行するために使用するコンピュータ。ユーザーは同時にかつネットワークを通じてのみアクセスすることが多い
- スーパーコンピュータ: 性能とコストが最高レベルのコンピュータ）もサーバーとして構成されており、通常は数億ドルもする
- 組み込みコンピュータ: 単一の専用アプリケーションまたはソフトウェア群を実行するために、他の装置の内部に組み込まれて使用されるコンピュータ

### 1.2

- Moore の法則に則って設計する: f
- 設計を単純化するために抽象化する: h
- 一般的な場合を高速化する: d
- 並列処理を通じた性能の向上: b
- パイプライン処理を通じた性能の向上: a
- 予測を通じた性能の向上: c
- 記憶階層: e
- 冗長性を通じた信頼性: g

### 1.3

- 高水準言語がコンパイラによって、アセンブリ言語に変換される。アセンブリ言語がアセンブラによって、機械語に変換される

### 1.4

#### a

- 3.9MB
  - 1280 \* 1024 \* 8 \* 3 / 8 = 3932160

#### b

- 0.31 秒
  - 3932160 \* 8 / 100000000 = 0.3145728

### 1.5

#### a

- MIPS を計算する
  - P1: 3.0 \* 10^9 / 1.5 / 10^6 = 2.0 \* 10^3
  - P2: 2.5 \* 10^9 / 1.0 / 10^6 = 2.5 \* 10^3
  - P3: 4.0 \* 10^9 / 2.2 / 10^6 = 1.8 \* 10^3
  - よって、P2 の性能が最高

#### b

- サイクル数は「クロック周波数」*「実行時間」
  - P1 のサイクル数: 30 \* 10^9
  - P2 のサイクル数: 25 \* 10^9
  - P3 のサイクル数: 40 \* 10^9
- 10 秒なので命令数は MIPS の 10 倍
  - P1 の命令数: 20 \* 10^9
  - P2 の命令数: 25 \* 10^9
  - P3 の命令数: 18 \* 10^9

#### c

- クロック周波数を 1.2 / 0.7 = 1.714 倍にしなければならない
  - P1: 5.1 \* 10^9
  - P2: 4.3 \* 10^9
  - P3: 6.9 \* 10^9

### 1.6

#### a

- P1: 1 \* 0.1 + 2 \* 0.2 + 3 \* 0.5 + 3 \* 0.2 = 2.6
- P2: 2

#### b

- 命令数は 1.0 \* 10^6 なので P1 は 2.6 \* 10^6、P2 は 2.0 \* 10^6
- 速さについて
  - P1: 2.6 \* 10^6 / (2.5 \* 10^9) = 1.04 \* 10^-3
  - P2: 2.0 \* 10^6 / (3 \* 10^9) = 0.67 \* 10^-3
  - なので P2 のほうが速い

### 1.7

#### a

- P1
  - 1.1 = 10^9 \* 10^-9 \* CPI なので CPI は 1.1
- P2
  - 1.5 = 1.2 \* 10^9 \* 10^-9 \* CPI なので CPI は 1.25

#### b

- A のクロック周波数を a、B のクロック周波数を b とする
- 10^9 \* 1.1 / a = 1.2 \* 1.25 \* 10^9 / b なので b / a = 1.2 \* 1.25 / 1.1 = 1.36
- A は B より 1.36 倍遅い

#### c

- 新しいコンパイラを使用した場合の実行時間は 6.0 \* 10^8 \* 1.1 \* 10^-9 = 0.66
- 1.1 / 0.66 = 1.67 より A を使用した場合に比べて、1.67 倍速い
- 1.5 / 0.66 = 2.27 より B を使用した場合に比べて、2.27 倍速い

### 1.8

#### 1.8.1

- 消費電力 = 1/2 \* 容量性負荷 \* 電圧の 2 乗 \* 切り替え周波数
- Pentinum 4 Prescott
  - 90 = 1/2 \* 容量性負荷 \* 1.25^2 \* 3.6 \* 10^9
  - よって容量性負荷は 90 \* 2 / (1.25^2 \* 3.6 \* 10^9) = 3.2 \* 10^-8 F
- Core i5 Ivy Bridge
  - 40 = 1/2 \* 容量性負荷 \* 0.9^2 \* 3.4 \* 10^9
  - よって容量性負荷は 40 \* 2 / (0.9^2 \* 3.4 \* 10^9) = 2.9 \* 10^-8 F

#### 1.8.2

- Pentinum 4 Prescott
  - 合計消費電力に対するパーセンテージ: 10 / 100 = 10%
  - 動的電力に対する割合: 1:9
- Core i5 Ivy Bridge
  - 合計消費電力に対するパーセンテージ: 30 / 70 = 43%
  - 動的電力に対する割合: 3:4

#### 1.8.3

- 消費電力 = 電圧 \* 電流で、電流を同じに保つので、電圧を 90％にする

### 1.9

#### 1.9.1

- クロックサイクル数
  - コアの数が 1 の時: 2.56 \* 10^9 + 12 \* 1.28 \* 10^9 + 5 \* 2.56 \* 10^8 = 19.2 \* 10^9
  - コアの数が n の時（n > 1）: 2.56 \* 10^9 \* (0.7 \* n) + 12 \* 1.28 \* 10^9 \* (0.7 \* n) + 5 \* 2.56 \* 10^8 = (25.6 / n + 1.28) \* 10^9
- コアの数: 1
  - 実行時間は 19.2 \* 10^9 / (2 \* 10^9) = 9.6 秒
- コアの数: 2
  - 実行時間は (25.6 / 2 + 1.28) \* 10^9 / (2 \* 10^9) = 7.04 秒
  - 相対速度向上率は 9.6 / 7.04 = 1.36 倍
- コアの数: 4
  - 実行時間は (25.6 / 4 + 1.28) \* 10^9 / (2 \* 10^9) = 3.84 秒
  - 相対速度向上率は 9.6 / 3.84 = 2.5 倍
- コアの数: 8
  - 実行時間は (25.6 / 8 + 1.28) \* 10^9 / (2 \* 10^9) = 2.24 秒
  - 相対速度向上率は 9.6 / 2.24 = 4.29 倍

#### 1.9.2

- クロックサイクル数
  - コアの数が 1 の時: 5.12 \* 10^9 + 12 \* 1.28 \* 10^9 + 5 \* 2.56 \* 10^8 = 21.76 \* 10^9
  - コアの数が n の時（n > 1）: 5.12 \* 10^9 \* (0.7 \* n) + 12 \* 1.28 \* 10^9 \* (0.7 \* n) + 5 \* 2.56 \* 10^8 = (29.257 / n + 1.28) \* 10^9
- コアの数: 1
  - 実行時間は 21.76 \* 10^9 / (2 \* 10^9) = 10.88 秒
- コアの数: 2
  - 実行時間は (29.257 / 2 + 1.28) \* 10^9 / (2 \* 10^9) = 7.95 秒
- コアの数: 4
  - 実行時間は (29.257 / 4 + 1.28) \* 10^9 / (2 \* 10^9) = 4.30 秒
- コアの数: 8
  - 実行時間は (29.257 / 8 + 1.28) \* 10^9 / (2 \* 10^9) = 2.47 秒

#### 1.9.3

- ロードストア命令の CPI を k とすると (2.56 \* 10^9 + k \* 1.28 \* 10^9 + 5 \* 2.56 \* 10^8) / (2 \* 10^9) = 3.84 を満たす
- k = (3.84 \* (2 \* 10^9) - 2.816 \* 10^9) / (1.28 \* 10^9) = 3.8 より CPI を 3.8 まで減らせばよい

### 1.10

#### 1.10.1

- 1 つ目
  - ダイの面積は 7.5^2 \* 3.14 / 84 = 2.103
  - 歩留まりは 1 / (1 + (0.020 \* 2.103 / 2))^2 = 0.96
- 2 つ目
  - ダイの面積は 10^2 \* 3.14 / 100 = 3.14
  - 歩留まりは 1 / (1 + (0.031 \* 3.14 / 2))^2 = 0.91

#### 1.10.2

- ダイ当たりのコスト = ウエーハ当たりのコスト / (ウエーハ当たりのダイの数 \* 歩留まり)
- 1 つ目
  - 12 / (84 \* 0.96) = 0.15
- 2 つ目
  - 15 / (100 \* 0.91) = 0.16

#### 1.10.3

- 1 つ目
  - ダイの面積は 7.5^2 \* 3.14 / (84 \* 1.1) = 1.91
  - 歩留まりは 1 / (1 + (0.020 \* 1.15 \* 1.91 / 2))^2 = 0.96
- 2 つ目
  - ダイの面積は 10^2 \* 3.14 / (100 \* 1.1) = 2.85
  - 歩留まりは 1 / (1 + (0.031 \* 1.15 \* 2.85 / 2))^2 = 0.91

#### 1.10.4

- 1 つ目
  - 改善前
    - 欠陥数を a とする
    - 0.92 = 1 / (1 + (a \* 2 / 2))^2 なので a = 1 / 0.92^0.5 - 1 = 0.043
  - 改善後
    - 欠陥数を b とする
    - 0.95 = 1 / (1 + (b \* 2 / 2))^2 なので b = 1 / 0.95^0.5 - 1 = 0.026

### 1.11

#### 1.11.1

- 750 = 2.389 \* 10^12 \* CPI \* 0.333 \* 10^-9 なので CPI = 750 / (2.389 \* 10^12 \* 0.333 \* 10^-9) = 0.94

#### 1.11.2

- 9650 / 750 = 12.87

#### 1.11.3

- 10％増加する

#### 1.11.4

- 1.1 \* 1.05 = 1.155 なので、15.5％増加する

#### 1.11.5

- 新しい SPECratio は 9650 / (750 \* 1.155) = 11.14
- (11.14 - 12.87) / 12.87 = -0.134 なので、13.4％悪化する

#### 1.11.6

- 700 = 2.389 \* 10^12 \* 0.85 \* CPI \* 0.25 \* 10^-9 なので、CPI = 700 / (2.389 \* 10^12 \* 0.85 \* 0.25 \* 10^-9) = 1.38

#### 1.11.7

- CPI とクロック周波数は反比例する

#### 1.11.8

- (750 - 700) / 750 = 0.067 より 6.7％削減した

#### 1.11.9

- 4GHz の時の実行時間は 960 \* 0.9 = 864ns
- 864 \* 10^-9 = 命令数 \* 1.61 \* 0.25 \* 10^-9 なので、命令数 =  864 \* 10^-9 / (1.61 \* 0.25 \* 10^-9) = 2147

#### 1.11.10

- 1.1 倍にする

#### 1.11.11

- クロック周波数を a とすると
- 960 \* 10^-9 \* 0.8 = 2147 \* 1.61 \* 0.85 / a なので a = 2147 \* 1.61 \* 0.85 / (960 \* 10^-9 \* 0.8) = 3.8 GHz

### 1.12

#### 1.12.1

- P1 の実行時間は 5.0 \* 10^9 \* 0.9 / (4 \* 10^9) = 1.125
- P2 の実行時間は 1.0 \* 10^9 \* 0.75 / (3 \* 10^9) = 0.25
- なので、クロック周波数は P1 のほうが高いが、性能は P2 のほうが高い

#### 1.12.2

- 「P1 と P2 の CPI が変わらないとして」の意味は、P1 の CPI が 0.9 のまま、P2 の CPI が 0.75 のままという意味と解釈
- 実行時間 = 1.0 \* 10^9 \* 0.9 / (4 \* 10^9) = 0.225
- なので、0.225 = 命令数 \* 0.75 / (3 \* 10^9) より、命令数 = 0.225 / (0.75 / (3 \* 10^9)) = 9.0 \* 10^8

#### 1.12.3

- MIPS は、クロック周波数 / CPI / 10^6
- P1 の MIPS は 4 \* 10^9 / 0.9 / 10^6 = 4.44 \* 10^3
- P2 の MIPS は 3 \* 10^9 / 0.75 / 10^6 = 4.00 \* 10^3
- なので、MIPS は P1 のほうが高いが、性能は P2 のほうが高い

#### 1.12.4

- P1 の MFLOPS は 4.44 \* 10^3 \* 0.4 = 1.78 \* 10^3
- P2 の MFLOPS は 4.00 \* 10^3 \* 0.4 = 1.60 \* 10^3

### 1.13

#### 1.13.1

- 70 \* 0.2 = 14 秒速くなる
- 14 / 250 = 5.6％短縮される

#### 1.13.2

- 合計時間の 20％は 250 \* 0.2 = 50 秒
- 50 / 70 = 71.4％短縮される

#### 1.13.3

- 分岐命令だけで 50 秒短縮することはできないので、不可能

### 1.14

#### 1.14.1

- 実行時間 = (50 \* 10^6 \* 1 + 110 \* 10^6 \* 1 + 80 \* 10^6 \* 4 + 16 \* 10^6 \* 2) / (2 \* 10^9) = 0.256
- 2 倍にするには 0.128 秒縮める必要があるが、浮動小数点命令では 0.025 秒しか縮められないので不可能

#### 1.14.2

- ロードストア命令はもともと 0.16 秒
- (0.16 - 0.128) / 0.16 = 20％ なので、80％短縮しなければならない

#### 1.14.3

- 短縮される時間は (50 \* 10^6 \* 0.4 \* 1 + 110 \* 10^6 \* 0.4 \* 1 + 80 \* 10^6 \* 0.3 \* 4 + 16 \* 10^6 \* 0.3 \* 2) / (2 \* 10^9) = 0.0848
- 0.0848 / 0.256 = 33.1％ 短縮される

### 1.15

- 2 台の場合
  - 100 / 2 + 4 = 54 秒
  - 速度向上比は 100 / 54 = 1.85
  - 理想との比較は 1.85 / 2 = 0.93
- 4 台の場合
  - 100 / 4 + 4 = 29 秒
  - 速度向上比は 100 / 29 = 3.45
  - 理想との比較は 3.45 / 4 = 0.86
- 8 台の場合
  - 100 / 8 + 4 = 16.5 秒
  - 速度向上比は 100 / 16.5 = 6.06
  - 理想との比較は 6.06 / 8 = 0.76
- 16 台の場合;
  - 100 / 16 + 4 = 10.25 秒
  - 速度向上比は 100 / 10.25 = 9.76
  - 理想との比較は 9.76 / 16 = 0.61
- 32 台の場合
  - 100 / 32 + 4 = 7.125 秒
  - 速度向上比は 100 / 7.125 = 14.04
  - 理想との比較は 14.04 / 32 = 0.44
- 64 台の場合
  - 100 / 64 + 4 = 5.5625 秒
  - 速度向上比は 100 / 5.5625 = 17.98
  - 理想との比較は 17.98 / 64 = 0.28
- 128 台の場合;
  - 100 / 128 + 4 = 4.78125 秒
  - 速度向上比は 100 / 4.78125 = 20.92
  - 理想との比較は 20.92 / 128 = 0.16
