# 概要

## 本

- [珠玉のプログラミング 本質を見抜いたアルゴリズムとデータ構造](https://amzn.to/2wcMOS0)

## かかった時間

- x 時間

## 読む前の状態

- xxx

## 進め方

- xxx

## 感想

- xxx

# 読書メモ

## 序文

- この本のコラムを読み進めるにあたって、言っておくべきことが 1 つあります
  - それは「急ぎすぎないでください」ということ

## 第 1 部: はじめに

- 最初の 5 つのカラムでプログラミングの基礎を考える

## 1. 真珠貝を開いて

- ケース
  - はじめの質問
    - 「ディスクでのソート方法を教えてもらえませんか」
  - 問題の正確な定義
    - 入力
      - ファイルは最大 n 個の正の整数を含んでいる。整数はそれぞれ n より小さく、n = 10^7 である。入力で同じ整数が現れたら決定的なエラーとなる。整数に他の情報は付随しない
    - 出力
      - 入力された整数を昇順にソートした一覧
    - 条件
      - ディスクには大きな容量の空きがあるが、メインメモリには 1 メガバイト程度の余裕しかない。実行時間は長くて数分。10 秒を切る必要はない
  - ポイント
    - 最大 1000 万個の異なる整数を大体 800 万ビットで表せるか
    - 1000 万ビット使えるなら「入力ファイルに整数 i があれば i 番目のビットを 1 にする」という方式で解ける

```
// セットを空にする
for i = [0, n)
  bit[i] = 0

// 対応する要素をセットに入れる
入力ファイル中にある整数 i に対し
  bit[i] = 1

// ソートされた出力を作る
for i = [0, n)
  if bit[i] == 1
    i を出力ファイルに書く
```

- 最初の教訓
  - 小さな問題の注意深い分析が、ときに驚くほどの実益を生む
- 原則
  - 正しい問題
    - 問題をきちんと定義することで、ことの 90% がすむと言える
  - ビット列というデータ構造
    - ビット列は「限られた範囲内にあり、密で、重複がなく、付随する情報もないようなデータのセット」を表すのに有効
    - また、これらの条件が満たされない場合でも、データ表のインデックスに、このような構造が使えることもある
  - 多パスのアルゴリズム
    - 入力データを何回か読み直し、少しずつ処理を進めていくアルゴリズム
  - 実行時間と使用メモリのトレードオフとそうでないもの
    - トレードオフとなることも多いが、私の経験では「使用するメモリを小さくすることで実行時間も小さくなる」ことのほうが多い
  - 単純な設計
    - 「設計が完璧だと思えるのは、もうこれ以上付け足すものがないときではなく、もうこれ以上取り去るものがないときだ」
