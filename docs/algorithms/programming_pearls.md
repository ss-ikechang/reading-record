# 概要

## 本

- [珠玉のプログラミング 本質を見抜いたアルゴリズムとデータ構造](https://amzn.to/2wcMOS0)

## かかった時間

- x 時間

## 読む前の状態

- xxx

## 進め方

- xxx

## 感想

- 特に印象に残ったこと
  - 問題をきちんと定義し、正しく理解すること
  - 最初のアイデアに飛びつく前に、より良いやり方がないか考える（正しく怠ける）
  - 入力、出力、中間のデータ構造を徹底的に理解し、適切なデータ構造を利用する

# 読書メモ

## 序文

- この本のコラムを読み進めるにあたって、言っておくべきことが 1 つあります
  - それは「急ぎすぎないでください」ということ

## 第 1 部: はじめに

- 最初の 5 つのカラムでプログラミングの基礎を考える

## 1. 真珠貝を開いて

- ケース
  - はじめの質問
    - 「ディスクでのソート方法を教えてもらえませんか」
  - 問題の正確な定義
    - 入力
      - ファイルは最大 n 個の正の整数を含んでいる。整数はそれぞれ n より小さく、n = 10^7 である。入力で同じ整数が現れたら決定的なエラーとなる。整数に他の情報は付随しない
    - 出力
      - 入力された整数を昇順にソートした一覧
    - 条件
      - ディスクには大きな容量の空きがあるが、メインメモリには 1 メガバイト程度の余裕しかない。実行時間は長くて数分。10 秒を切る必要はない
  - ポイント
    - 最大 1000 万個の異なる整数を大体 800 万ビットで表せるか
    - 1000 万ビット使えるなら「入力ファイルに整数 i があれば i 番目のビットを 1 にする」という方式で解ける

```
// セットを空にする
for i = [0, n)
  bit[i] = 0

// 対応する要素をセットに入れる
入力ファイル中にある整数 i に対し
  bit[i] = 1

// ソートされた出力を作る
for i = [0, n)
  if bit[i] == 1
    i を出力ファイルに書く
```

- 教訓
  - 小さな問題の注意深い分析が、ときに驚くほどの実益を生む
- 原則
  - 正しい問題
    - 問題をきちんと定義することで、ことの 90% がすむと言える
  - ビット列というデータ構造
    - ビット列は「限られた範囲内にあり、密で、重複がなく、付随する情報もないようなデータのセット」を表すのに有効
    - また、これらの条件が満たされない場合でも、データ表のインデックスに、このような構造が使えることもある
  - 多パスのアルゴリズム
    - 入力データを何回か読み直し、少しずつ処理を進めていくアルゴリズム
  - 実行時間と使用メモリのトレードオフとそうでないもの
    - トレードオフとなることも多いが、私の経験では「使用するメモリを小さくすることで実行時間も小さくなる」ことのほうが多い
  - 単純な設計
    - 「設計が完璧だと思えるのは、もうこれ以上付け足すものがないときではなく、もうこれ以上取り去るものがないときだ」

## 2:「ああ(そうか)！」アルゴリズム

- 「ああ(そうか)！」というひらめきは、よく勉強して得られるというものではない。しかし、プログラミングの前にも、途中にも、また終わってからもよく考えるプログラマなら誰でも経験できるもの
- 3 つの問題
  - A: 最大で 40 億個の 32 ビット整数がでたらめな順に入っているファイルがある。このファイルに入っていない 32 ビット整数を 1 つ見つけられるか。メインメモリが非常に大きい場合はどうするか。また、外部に作業ファイルを作ることはできてもメインメモリには数百バイトほどの余裕しかないときはどうするか
  - B: 要素が n 個ある配列を左方向に i 要素分回転させるにはどうすればいいか。例えば n = 8 で i = 3 の時、配列 abcdefgh を defghabc にする。単純には n 個の作業用配列を作って n ステップで仕事すればよいが、メモリを数十バイトしか使わずに実行時間も n に比例するだけのように回転させられるか
  - C: 英語の辞書が与えられた時に、すべてのアナグラムを見つけられるか。例えば、pots、stop、tops は同じ文字を入れ替えているだけなのでアナグラムとなる。つまり、単語の集合が与えられて、すべてのアナグラムが見つけられればよい
- A について
  - 入力される整数の個数を n とする
  - n に比例する回数で問題を解けるか
    - メインメモリが大きい場合はコラム 1 のようにビット列の方法で解ける。メインメモリに余裕が少ない場合にはどうするか
    - ソートを利用する場合、`n log n` に比例する
  - 解
    - やり方
      - 32 個のビット列の 2 分探索の問題と考えるとわかりやすくなる
      - 最初のビットが 0 のものと 1 のものにわけて、2 つのファイルに書き込んでいく
        - 処理が終わった時に、最大で 20 億個の整数が書かれる
      - 次に、出力されたファイルで整数の個数の少ない方を新しい入力ファイルにし、今度は 2 番目のビットを見て、また 2 つのファイルに分ける
      - これを繰り返す
    - 実行時間
      - 最初は n 回の読み込み、次は n/2 回、... と続くので実行時間は n に比例する
- B について
  - いくつかやり方がある
    - 順々に移動させていく
    - 前の部分と後ろの部分を入れ替える
  - これらでも条件を満たして解くことはできるが、やや複雑でデリケートなコーディングになる
  - 解
    - ab から ba を作ると考える
    - a を逆向きにしたものを a^r とすると
    - (a^r b^r)^r は ba となる
    - これは再帰的に解くことができ、ミスもしにくいコードとなる
- C について
  - 3 つの段階で考える
    - sign
      - 各英単語の文字をソートして、それを「印」とする
    - sort
      - sign で作成した印に従ってソートする
    - squash
      - sort で同じ印を持つものが連続しているので、それらをまとめる
- 原則
  - ソート
    - ソートの明らかな使い道は、整列された出力を作ること
    - しかし、ソートの用途はこれだけではない
      - アナグラムの問題では、同じ要素をまとめるためにソートを利用した
  - 2 分探索
    - 2 分探索はソートされたデータ中での探索方法として非常に有効で、メインメモリ上とディスク上のどちらでも使える
    - 唯一の問題点は、データの全体がはじめからわかっており、しかもソートされている必要があるということ
  - 印 (シグナチャー、署名)
    - 同値関係によって定義されたクラスに、ある要素が属するかどうか調べるのに印を定義しておくと便利
  - 問題を解く見通し
    - 良いプログラマは少々怠け者
    - 最初のアイデアに飛びつく前に、椅子の背にもたれて、何かひらめかないか待ってみる
    - もちろん時間配分を身につけることも大事
    - このようなスキルは問題を解き、その解法をまた考え直す、そういう経験を積むことによって得られるもの

## 3: データで決まるプログラムの構造

- どうして小さなプログラムで十分なのに、大きなプログラムを書いてしまうのか
  - 1 つは「怠け癖」がないため最初に思いついたアイデアに飛びついてしまうことだが、他にも多くの理由が考えられる
  - 心理的な障害があって、思いつかない
  - 元のプログラムを改善したことに満足して、すぐ目の前にある改善点を見落としてしまう
- 教訓
  - 小さいプログラムで済む問題に、大きなプログラムを書くな
- アドバイス
  - メモリが足りなくなって途方にくれているプログラマは、プログラムからちょっと離れ、椅子の背にもたれて、データについて考えてみると良い
  - 表現こそがプログラミングの本質
- 椅子の背にもたれた時に考えるべき原則
  - コードの繰り返しには配列を使え
  - 複雑な構造はカプセル化せよ
  - 可能なら優れたツールを使え
  - データによってプログラムの構造を決めよ
    - 適切なデータ構造のおかげで複雑なプログラムが小さくなることがあるように、データがプログラムの構造を決めうる
    - 優秀なプログラマは、コードを書く前に、そのプログラムの入力、出力、中間のデータ構造を徹底的に理解する
