# 概要

## 本

- [アルゴリズムイントロダクション 第3版 総合版 (世界標準MIT教科書) | T. コルメン, R. リベスト, C. シュタイン, C. ライザーソン, Thomas H. Cormen, Clifford Stein, Ronald L. Rivest, Charles E. Leiserson, 浅野 哲夫, 岩野 和生, 梅尾 博司, 山下 雅史, 和田 幸一](https://amzn.to/2F8X8M4)

## 参考

- [Introduction to Algorithms, Third Edition | The MIT Press](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)

## かかった時間

- x 時間

## 読む前の状態

- xxx

## 進め方

- 演習問題は解いていない

## 感想

- xxx

# 読書メモ

## 1. 計算におけるアルゴリズムの役割

- アルゴリズムは、ある値または値の集合を入力(input)として取り、ある値または値の集合を出力(output)として生成する、明確に定義された計算手続き

## 2. さあ、始めよう

- 挿入ソート(insertion sort)
  - トランプの手札をソートするようなイメージ
    - 左手を空にし、テーブルの上にカードを裏向きに置く
    - テーブルから 1 枚ずつカードを取って、左手の正しい位置に挿入していく

```
for j = 2 to A.length
  key = A[j]
  // A[j]をソート済みの列A[1..j-1]に挿入する
  i = j - 1
  while i > 0 かつ A[i] > key
    A[i + 1] = A[i]
    i = i - 1
  A[i + 1] = key
```

- ループ不変式(loop invariant)
  - 簡単に言うと、ループの全ての反復に対して、保持される条件
  - 厳密に言うと以下の 3 つの性質がある
    - 初期条件
      - ループの実行開始直前で、ループ不変式は真
    - ループ内条件
      - ループの何回目かの繰り返しの直前でループ不変式が真ならば、次の繰り返しの直前でも真である
    - 終了条件
      - ループが停止した時、アルゴリズムの正当性の証明につながる有力な性質が不変式から得られる
- アルゴリズムの解析
  - アルゴリズムの実行に必要な資源量を予測することを、アルゴリズムを解析する(analyzing)という
  - 多くの場合、測定したいのは計算時間
  - アルゴリズムを解析するには、使用する実現技術のモデルを設定する必要がある。このモデルには実現技術で用いられる資源とそのコストのモデルが含まれる
    - 本書では、基本的な単一プロセッサの計算モデルであるランダムアクセスマシン(RAM)を実現技術として仮定し、アルゴリズムは計算機プログラムとして実現する
    - RAM モデルでは命令は 1 つずつ逐次的に実行され、並列演算は存在しない
- 実行時間
  - ある特定の入力に対するアルゴリズムの実行時間(running time)は、実行される基本演算または「ステップ」の数
- 最悪時と平均時の解析
  - 本書では通常の場合、最悪実行時間(worst-case running time)だけを考える
    - 以下の 3 つが理由
      - 実行時間の上界を知ることで、アルゴリズムの実行にそれ以上の時間がかからないことを保証できる
      - あるアルゴリズムでは、最悪の場合がかなり頻繁に生ずることがある
      - 平均的な場合が、最悪の場合と同じくらい悪いことが多い
- 増加のオーダ(order of growth)
  - 実行時間の増加率が重要
  - 例えば挿入ソートだと θ(n^2) となる
- 分割統治法(devide-and-conquer)
  - 再帰構造を持つアルゴリズムは、多くの場合、分割統治法に基づいて設計されている
  - 分割統治パラダイムの再帰の各レベルは以下の 3 つの段階から構成される
    - 分割
      - 問題をいくつかの同じ問題のより小さいインスタンスである部分問題に分割する
    - 統治
      - 部分問題を再帰的に解くことによって統治する。ただし、部分問題のサイズが十分小さい場合は直接的な方法で解く
    - 結合
      - 部分問題の解を組み合わせて元の問題の解を得る
- マージソート(merge sort)

```
MERGE-SORT(A, p, r)
if p < r
  q = [(p + r) / 2]
  MERGE-SORT(A, p, q)
  MERGE-SORT(A, q + 1, r)
  MERGE(A, p, q, r)

MERGE(A, p, q, r)
n1 = q - p + 1
n2 = r - q
// L[1..n1+1] と R[1..n2+1] を2つの新しい配列とする
for i = 1 to n1
  L[i] = A[p + i - 1]
for j = 1 to n2
  R[i] = A[q + j]
L[n1 + 1] = ∞
R[n2 + 1] = ∞
i = 1
j = 1
for k = p to r
  if L[i] <= R[j]
    A[k] = L[i]
    i = i + 1
  else
    A[k] = R[j]
    j = j + 1
```

- 分割統治アルゴリズムの解析
  - 問題を a 個の部分問題に分割され、各部分問題のサイズは元の問題の 1/b であるとする
  - また問題を部分問題に分割するのに D(n) 時間かかり、部分問題の解を結合するのに C(n) 時間かかるとする
  - 以下の漸化式で表せる
    - T = θ(1) (n <= c の時)
    - T = aT(n/b) + D(n) + C(n) (それ以外の時)
  - このような形式の漸化式を解く方法は 4 章で学ぶ
  - マージソートの場合は θ(nlgn)

## 3: 関数の増加

- θ記法(θ-notation)
  - 定義
    - ある与えられた関数 g(n) に対して、θ(g(n)) を以下のように定義する
      - θ(g(n)) = {f(n): ある正の定数 c1, c2, n0 が存在して、すべての n >= n0 に対して 0 <= c1g(n) <= f(n) <= c2g(n) を満たす}
  - 上記の時、g(n) は f(n) の漸近的にタイトな限界(asymptotically tight bound)という
- Ｏ記法(Ｏ-notation、ビッグオーまたはオー)
  - θ記法は関数を漸近的に上下から限定する。漸近的上界(asymptotic upper bound)だけに関心がある時はＯ記法を用いる
  - 定義
    - Ｏ(g(n)) = {f(n): ある正の定数 c, n0 が存在して、すべての n >= n0 に対して 0 <= f(n) <= cg(n) を満たす}
- Ω記法(Ω-notation、ビッグオメガまたはオメガ)
  - Ｏ記法が関数の漸近的上界を与えるのに対し、Ω記法は漸近的下界(asymptotically lower bound)を与える
  - 定義
    - Ω(g(n)) = {f(n): ある正の定数 c, n0 が存在して、すべての n >= n0 に対して 0 <= cg(n) <= f(n) を満たす}
- o 記法(o-notation、リトルオー)
  - 漸近的にタイトでない上界を表すのに o 記法を用いる
  - 定義
    - o(g(n)) = {f(n): 任意の正の定数 c > 0 に対して、ある正の定数 n0 > 0 が存在して、すべての n >= n0 に対して 0 <= f(n) < cg(n) を満たす}
- ω記法(ω-notation、リトルオメガ)
  - 漸近的にタイトでない下界を表すのにω記法を用いる
  - 定義
    - ω(g(n)) = {f(n): 任意の正の定数 c > 0 に対して、ある正の定数 n0 > 0 が存在して、すべての n >= n0 に対して 0 <= cg(n) < f(n) を満たす}
- 関数の比較
  - 推移性
    - f(n) = θ(g(n)) かつ g(n) = θ(h(n)) ならば f(n) = θ(h(n))
    - f(n) = Ｏ(g(n)) かつ g(n) = Ｏ(h(n)) ならば f(n) = Ｏ(h(n))
    - f(n) = Ω(g(n)) かつ g(n) = Ω(h(n)) ならば f(n) = Ω(h(n))
    - f(n) = o(g(n)) かつ g(n) = o(h(n)) ならば f(n) = o(h(n))
    - f(n) = ω(g(n)) かつ g(n) = ω(h(n)) ならば f(n) = ω(h(n))
  - 反射性
    - f(n) = θ(f(n))
    - f(n) = Ｏ(f(n))
    - f(n) = Ω(f(n))
  - 対称性
    - f(n) = θ(g(n)) の時、かつその時に限り g(n) = θ(f(n))
  - 転置対称性
    - f(n) = Ｏ(g(n)) の時、かつその時に限り g(n) = Ω(f(n))
    - f(n) = o(g(n)) の時、かつその時に限り g(n) = ω(f(n))
