// LICENSE : MIT
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var structured_source_1 = __importDefault(require("structured-source"));
var unified = require("unified");
var parse = require("rehype-parse");
var html2hast = function (html) {
    return unified()
        .use(parse, { fragment: true })
        .parse(html);
};
var StringSource = /** @class */ (function () {
    function StringSource(node) {
        this.rootNode = node;
        this.tokenMaps = [];
        this.generatedString = "";
        // pre calculate
        this._stringify(this.rootNode);
        this.originalSource = new structured_source_1.default(this.rootNode.raw);
        this.generatedSource = new structured_source_1.default(this.generatedString);
    }
    StringSource.prototype.toString = function () {
        return this.generatedString;
    };
    /**
     * @deprecated use originalIndexFromIndex instead of
     * @param targetIndex
     */
    StringSource.prototype.originalIndexFor = function (targetIndex) {
        return this.originalIndexFromIndex(targetIndex);
    };
    /**
     * @deprecated use originalPositionFromPosition instead of
     * @param generatedPosition
     * @param {boolean}  isEnd - is the position end of the node?

     * @returns {Object}
     */
    StringSource.prototype.originalPositionFor = function (generatedPosition, isEnd) {
        if (isEnd === void 0) { isEnd = false; }
        return this.originalPositionFromPosition(generatedPosition, isEnd);
    };
    /**
     * get original index from generated index value
     * @param {number} generatedIndex - position is a index value.
     * @param {boolean}  isEnd - is the position end of the node?
     * @returns {number|undefined} original
     */
    StringSource.prototype.originalIndexFromIndex = function (generatedIndex, isEnd) {
        var _this = this;
        if (isEnd === void 0) { isEnd = false; }
        var hitTokenMaps = this.tokenMaps.filter(function (tokenMap, index) {
            var generated = tokenMap.generated;
            var nextTokenMap = _this.tokenMaps[index + 1];
            var nextGenerated = nextTokenMap ? nextTokenMap.generated : null;
            if (!generated) {
                return false;
            }
            if (nextGenerated) {
                if (generated[0] <= generatedIndex && generatedIndex <= nextGenerated[0]) {
                    return true;
                }
            }
            else {
                if (generated[0] <= generatedIndex && generatedIndex <= generated[1]) {
                    return true;
                }
            }
            return false;
        });
        if (hitTokenMaps.length === 0) {
            return;
        }
        /**
         * **Str**ABC
         *     |
         *     |
         *   generatedIndex
         *
         * If isEnd is true, generatedIndex is end of **Str** node.
         * If isEnd is false, generatedIndex is index of ABC node.
         */
        var hitTokenMap = isEnd ? hitTokenMaps[0] : hitTokenMaps[hitTokenMaps.length - 1];
        // <----------->[<------------->|text]
        //              ^        ^
        //   position-generated  intermediate-origin
        // <-------------->[<------------->|text]
        //       |         |
        //  outer adjust   _
        //            inner adjust = 1
        if (!hitTokenMap.generated) {
            console.warn("hitTokenMap.generated is missing", hitTokenMap);
            return;
        }
        var outerAdjust = generatedIndex - hitTokenMap.generated[0];
        var innerAdjust = hitTokenMap.intermediate[0] - hitTokenMap.original[0];
        return outerAdjust + innerAdjust + hitTokenMap.original[0];
    };
    /**
     * get original position from generated position
     * @param {object} position
     * @param {boolean}  isEnd - is the position end of the node?
     * @returns {object} original position
     */
    StringSource.prototype.originalPositionFromPosition = function (position, isEnd) {
        if (isEnd === void 0) { isEnd = false; }
        if (typeof position.line === "undefined" || typeof position.column === "undefined") {
            throw new Error("position.{line, column} should not undefined: " + JSON.stringify(position));
        }
        var generatedIndex = this.generatedSource.positionToIndex(position);
        if (isNaN(generatedIndex)) {
            // Not Found
            return;
        }
        var originalIndex = this.originalIndexFromIndex(generatedIndex, isEnd);
        if (originalIndex === undefined) {
            return;
        }
        return this.originalSource.indexToPosition(originalIndex);
    };
    /**
     * get original index from generated position
     * @param {object} generatedPosition
     * @param {boolean}  isEnd - is the position end of the node?
     * @returns {number} original index
     */
    StringSource.prototype.originalIndexFromPosition = function (generatedPosition, isEnd) {
        if (isEnd === void 0) { isEnd = false; }
        var originalPosition = this.originalPositionFromPosition(generatedPosition, isEnd);
        if (originalPosition === undefined) {
            return;
        }
        return this.originalSource.positionToIndex(originalPosition);
    };
    /**
     * get original position from generated index
     * @param {number} generatedIndex
     * @param {boolean} isEnd - is the position end of the node?
     * @return {object} original position
     */
    StringSource.prototype.originalPositionFromIndex = function (generatedIndex, isEnd) {
        if (isEnd === void 0) { isEnd = false; }
        var originalIndex = this.originalIndexFromIndex(generatedIndex, isEnd);
        if (originalIndex === undefined) {
            return;
        }
        return this.originalSource.indexToPosition(originalIndex);
    };
    StringSource.prototype.isParagraphNode = function (node) {
        return node.type === "Paragraph";
    };
    StringSource.prototype.isStringNode = function (node) {
        return node.type === "Str";
    };
    /**
     *
     * @param node
     * @returns {string|undefined}
     * @private
     */
    StringSource.prototype._getValue = function (node) {
        if (node.value) {
            return node.value;
        }
        else if (node.alt) {
            return node.alt;
        }
        else if (node.title) {
            // See https://github.com/azu/textlint-rule-sentence-length/issues/6
            if (node.type === "Link") {
                return;
            }
            return node.title;
        }
        else {
            return;
        }
    };
    StringSource.prototype._nodeRangeAsRelative = function (node) {
        // relative from root
        return [node.range[0] - this.rootNode.range[0], node.range[1] - this.rootNode.range[0]];
    };
    StringSource.prototype._valueOf = function (node, parent) {
        if (!node) {
            return;
        }
        // [padding][value][padding]
        // =>
        // [value][value][value]
        var value = this._getValue(node);
        if (!value) {
            return;
        }
        if (parent === null || parent === undefined) {
            return;
        }
        // <p><Str /></p>
        if (this.isParagraphNode(parent) && this.isStringNode(node)) {
            return {
                original: this._nodeRangeAsRelative(node),
                intermediate: this._nodeRangeAsRelative(node),
                generatedValue: value
            };
        }
        // <p><code>code</code></p>
        // => container is <p>
        // <p><strong><Str /></strong></p>
        // => container is <strong>
        var container = this.isParagraphNode(parent) ? node : parent;
        var rawValue = container.raw;
        // avoid match ! with ![
        // TODO: indexOf(value, 1) 1 is unexpected ...
        var paddingLeft = rawValue.indexOf(value, 1) === -1 ? 0 : rawValue.indexOf(value, 1);
        var paddingRight = rawValue.length - (paddingLeft + value.length);
        // original range should be relative value from rootNode
        var originalRange = this._nodeRangeAsRelative(container);
        var intermediateRange = [originalRange[0] + paddingLeft, originalRange[1] - paddingRight];
        return {
            original: originalRange,
            intermediate: intermediateRange,
            generatedValue: value
        };
    };
    StringSource.prototype._addTokenMap = function (tokenMap) {
        if (tokenMap == null) {
            return;
        }
        var addedTokenMap = Object.assign({}, tokenMap);
        if (this.tokenMaps.length === 0) {
            var textLength = addedTokenMap.intermediate[1] - addedTokenMap.intermediate[0];
            addedTokenMap["generated"] = [0, textLength];
        }
        else {
            var textLength = addedTokenMap.intermediate[1] - addedTokenMap.intermediate[0];
            addedTokenMap["generated"] = [this.generatedString.length, this.generatedString.length + textLength];
        }
        this.generatedString += tokenMap.generatedValue;
        this.tokenMaps.push(addedTokenMap);
    };
    /**
     * Compute text content of a node.  If the node itself
     * does not expose plain-text fields, `toString` will
     * recursively mapping
     *
     * @param {Node} node - Node to transform to a string.
     * @param {Node} [parent] - Parent Node of the `node`.
     */
    StringSource.prototype._stringify = function (node, parent) {
        var _this = this;
        var isHTML = node.type === "Html";
        var currentNode = isHTML ? html2hast(node.value) : node;
        var value = this._valueOf(currentNode, parent);
        if (value) {
            return value;
        }
        if (!isParentNode(node)) {
            return;
        }
        currentNode.children.forEach(function (childNode) {
            if (!isParentNode(node)) {
                return;
            }
            var tokenMap = _this._stringify(childNode, node);
            if (tokenMap) {
                _this._addTokenMap(tokenMap);
            }
        });
    };
    return StringSource;
}());
exports.default = StringSource;
var isParentNode = function (node) {
    return "children" in node;
};
//# sourceMappingURL=StringSource.js.map