{"version":3,"sources":["../src/token-utils.js"],"names":["is助詞Token","token","test","pos","is読点Token","surface_form","concatToken","aToken","bToken","pos_detail_1","concatJoishiTokens","tokens","newTokens","forEach","prevToken","length","push","createKeyFromKey","restoreToSurfaceFromKey","key","split"],"mappings":"AAAA;AACA,a,CACA;;;;;;;AACO,IAAMA,SAAS,GAAG,SAAZA,SAAY,CAACC,KAAD,EAAW;AAChC;AACA,SAAOA,KAAK,IAAI,MAAMC,IAAN,CAAWD,KAAK,CAACE,GAAjB,CAAhB;AACH,CAHM;;;;AAKA,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAACH,KAAD,EAAW;AAChC,SAAOA,KAAK,CAACI,YAAN,KAAuB,GAAvB,IAA8BJ,KAAK,CAACE,GAAN,KAAc,IAAnD;AACH,CAFM;AAGP;;;;;;;;;;AAMA,IAAMG,WAAW,GAAG,SAAdA,WAAc,CAACC,MAAD,EAASC,MAAT,EAAoB;AACpCD,EAAAA,MAAM,CAACF,YAAP,IAAuBG,MAAM,CAACH,YAA9B;AACAE,EAAAA,MAAM,CAACJ,GAAP,IAAcK,MAAM,CAACL,GAArB;AACAI,EAAAA,MAAM,CAACE,YAAP,IAAuBD,MAAM,CAACH,YAA9B;AACA,SAAOE,MAAP;AACH,CALD;AAMA;;;;;;;AAKO,IAAMG,kBAAkB,GAAG,SAArBA,kBAAqB,CAACC,MAAD,EAAY;AAC1C,MAAMC,SAAS,GAAG,EAAlB;AACAD,EAAAA,MAAM,CAACE,OAAP,CAAe,UAACZ,KAAD,EAAW;AACtB,QAAMa,SAAS,GAAGF,SAAS,CAACA,SAAS,CAACG,MAAV,GAAmB,CAApB,CAA3B;;AACA,QAAIf,SAAS,CAACC,KAAD,CAAT,IAAoBD,SAAS,CAACc,SAAD,CAAjC,EAA8C;AAC1CF,MAAAA,SAAS,CAACA,SAAS,CAACG,MAAV,GAAmB,CAApB,CAAT,GAAkCT,WAAW,CAACQ,SAAD,EAAYb,KAAZ,CAA7C;AACH,KAFD,MAEO;AACHW,MAAAA,SAAS,CAACI,IAAV,CAAef,KAAf;AACH;AACJ,GAPD;AAQA,SAAOW,SAAP;AACH,CAXM,C,CAYP;AACA;AACA;;;;;AACO,IAAMK,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAChB,KAAD,EAAW;AACvC;AACA,mBAAUA,KAAK,CAACI,YAAhB,cAAgCJ,KAAK,CAACE,GAAtC,cAA6CF,KAAK,CAACQ,YAAnD;AACH,CAHM,C,CAIP;;;;;AACO,IAAMS,uBAAuB,GAAG,SAA1BA,uBAA0B,CAACC,GAAD,EAAS;AAC5C,SAAOA,GAAG,CAACC,KAAJ,CAAU,GAAV,EAAe,CAAf,CAAP;AACH,CAFM","sourcesContent":["// LICENSE : MIT\n\"use strict\";\n// 助詞どうか\nexport const is助詞Token = (token) => {\n    // 結合しているtokenは助詞助詞のようになってるため先頭一致で見る\n    return token && /^助詞/.test(token.pos);\n};\n\nexport const is読点Token = (token) => {\n    return token.surface_form === \"、\" && token.pos === \"名詞\";\n};\n/**\n * aTokenの_extraKeyに結合したkeyを追加する\n * @param {Object} aToken\n * @param {Object} bToken\n * @returns {Object}\n */\nconst concatToken = (aToken, bToken) => {\n    aToken.surface_form += bToken.surface_form;\n    aToken.pos += bToken.pos;\n    aToken.pos_detail_1 += bToken.surface_form;\n    return aToken;\n};\n/**\n * 助詞+助詞 というように連続しているtokenを結合し直したtokenの配列を返す\n * @param {Array} tokens\n * @returns {Array}\n */\nexport const concatJoishiTokens = (tokens) => {\n    const newTokens = [];\n    tokens.forEach((token) => {\n        const prevToken = newTokens[newTokens.length - 1];\n        if (is助詞Token(token) && is助詞Token(prevToken)) {\n            newTokens[newTokens.length - 1] = concatToken(prevToken, token);\n        } else {\n            newTokens.push(token);\n        }\n    });\n    return newTokens;\n};\n// 助詞tokenから品詞細分類1までを元にしたkeyを作る\n// http://www.unixuser.org/~euske/doc/postag/index.html#chasen\n// http://chasen.naist.jp/snapshot/ipadic/ipadic/doc/ipadic-ja.pdf\nexport const createKeyFromKey = (token) => {\n    // e.g.) \"は:助詞.係助詞\"\n    return `${token.surface_form}:${token.pos}.${token.pos_detail_1}`;\n};\n// keyからsurfaceを取り出す\nexport const restoreToSurfaceFromKey = (key) => {\n    return key.split(\":\")[0];\n};"],"file":"token-utils.js"}