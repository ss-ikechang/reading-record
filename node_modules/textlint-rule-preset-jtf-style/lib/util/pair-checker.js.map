{"version":3,"sources":["../../src/util/pair-checker.js"],"names":["checkPair","context","left","right","Syntax","RuleError","report","getSource","helper","RuleHelper","isInParagraph","currentStrInParagraph","foundMissingPairNodes","foundLeft","matchParentheses","forEach","node","text","leftIndex","indexOf","push","index","pairIndex","pop","Paragraph","isChildNode","BlockQuote","Str","missingPairList","length"],"mappings":"AAAA;AACA;AACA;;;;;;;;;;;;;AAOA;;AACA;;;;;;AACO,SAASA,SAAT,CAAmBC,OAAnB,QAA6C;AAAA;;AAAA,MAAfC,IAAe,QAAfA,IAAe;AAAA,MAATC,KAAS,QAATA,KAAS;AAChD,uBAAOD,IAAP;AACA,uBAAOC,KAAP;AAFgD,MAG1CC,MAH0C,GAGDH,OAHC,CAG1CG,MAH0C;AAAA,MAGlCC,SAHkC,GAGDJ,OAHC,CAGlCI,SAHkC;AAAA,MAGvBC,MAHuB,GAGDL,OAHC,CAGvBK,MAHuB;AAAA,MAGfC,SAHe,GAGDN,OAHC,CAGfM,SAHe;AAIhD,MAAIC,MAAM,GAAG,IAAIC,8BAAJ,CAAeR,OAAf,CAAb;AACA,MAAIS,aAAa,GAAG,KAApB;AACA,MAAIC,qBAAqB,GAAG,EAA5B;AACA;;;;;;AAKA,MAAMC,qBAAqB,GAAG,SAAxBA,qBAAwB,CAAAD,qBAAqB,EAAI;AACnD,QAAIE,SAAS,GAAG,KAAhB;AACA,QAAIC,gBAAgB,GAAG,EAAvB;AACAH,IAAAA,qBAAqB,CAACI,OAAtB,CAA8B,UAAAC,IAAI,EAAI;AAClC,UAAMC,IAAI,GAAGV,SAAS,CAACS,IAAD,CAAtB,CADkC,CAElC;;AACA,UAAIE,SAAS,GAAG,CAAC,CAAjB;;AACA,UAAI,CAACL,SAAL,EAAgB;AACZK,QAAAA,SAAS,GAAGD,IAAI,CAACE,OAAL,CAAajB,IAAb,CAAZ;;AACA,YAAIgB,SAAS,KAAK,CAAC,CAAnB,EAAsB;AAClBJ,UAAAA,gBAAgB,CAACM,IAAjB,CAAsB;AAClBJ,YAAAA,IAAI,EAAJA,IADkB;AAElBK,YAAAA,KAAK,EAAEH;AAFW,WAAtB;AAIAL,UAAAA,SAAS,GAAG,IAAZ;AACH;AACJ,OAbiC,CAclC;;;AACA,UAAIS,SAAS,GAAGL,IAAI,CAACE,OAAL,CAAahB,KAAb,EAAoBe,SAAS,GAAG,CAAhC,CAAhB;;AACA,UAAII,SAAS,KAAK,CAAC,CAAnB,EAAsB;AAClBR,QAAAA,gBAAgB,CAACS,GAAjB;AACAV,QAAAA,SAAS,GAAG,KAAZ;AACH;AACJ,KApBD;AAqBA,WAAOC,gBAAP;AACH,GAzBD;;AA0BA,4CACKV,MAAM,CAACoB,SADZ,YACuBR,IADvB,EAC6B;AACrB,QAAIR,MAAM,CAACiB,WAAP,CAAmBT,IAAnB,EAAyB,CAACZ,MAAM,CAACsB,UAAR,CAAzB,CAAJ,EAAmD;AAC/C;AACH;;AACDf,IAAAA,qBAAqB,GAAG,EAAxB;AACAD,IAAAA,aAAa,GAAG,IAAhB;AACH,GAPL,0BAQKN,MAAM,CAACuB,GARZ,YAQiBX,IARjB,EAQuB;AACf,QAAI,CAACN,aAAL,EAAoB;AAChB;AACH;;AACDC,IAAAA,qBAAqB,CAACS,IAAtB,CAA2BJ,IAA3B;AACH,GAbL,oCAcQZ,MAAM,CAACoB,SAdf,4BAcmC;AAC3B,QAAMI,eAAe,GAAGhB,qBAAqB,CAACD,qBAAD,CAA7C,CAD2B,CAE3B;;AACAD,IAAAA,aAAa,GAAG,KAAhB,CAH2B,CAI3B;;AACA,QAAIkB,eAAe,CAACC,MAAhB,KAA2B,CAA/B,EAAkC;AAC9B;AACH;;AACDD,IAAAA,eAAe,CAACb,OAAhB,CAAwB,iBAAqB;AAAA,UAAlBC,IAAkB,SAAlBA,IAAkB;AAAA,UAAZK,KAAY,SAAZA,KAAY;AACzCf,MAAAA,MAAM,CACFU,IADE,EAEF,IAAIX,SAAJ,WAAiBH,IAAjB,2CAA6BC,KAA7B,mEAA8CD,IAA9C,SAAqDC,KAArD,GAA8D;AAC1DkB,QAAAA,KAAK,EAALA;AAD0D,OAA9D,CAFE,CAAN;AAMH,KAPD;AAQH,GA9BL;AAgCH","sourcesContent":["// LICENSE : MIT\n\"use strict\";\n/**\n * 「と」といったペアがちゃんと閉じられているかをチェックします\n * @param {object} context\n * @param {string} left\n * @param {string} right\n * @returns {object}\n */\nimport assert from \"assert\";\nimport { RuleHelper } from \"textlint-rule-helper\";\nexport function checkPair(context, { left, right }) {\n    assert(left);\n    assert(right);\n    let { Syntax, RuleError, report, getSource } = context;\n    let helper = new RuleHelper(context);\n    let isInParagraph = false;\n    let currentStrInParagraph = [];\n    /**\n     * `Str` nodeの配列を受け取り、pairが見つからないnodeを返す\n     * @param {Object} currentStrInParagraph\n     * @returns {{node, index}[]}\n     */\n    const foundMissingPairNodes = currentStrInParagraph => {\n        let foundLeft = false;\n        let matchParentheses = [];\n        currentStrInParagraph.forEach(node => {\n            const text = getSource(node);\n            // left を探す\n            let leftIndex = -1;\n            if (!foundLeft) {\n                leftIndex = text.indexOf(left);\n                if (leftIndex !== -1) {\n                    matchParentheses.push({\n                        node,\n                        index: leftIndex\n                    });\n                    foundLeft = true;\n                }\n            }\n            // right を探す\n            let pairIndex = text.indexOf(right, leftIndex + 1);\n            if (pairIndex !== -1) {\n                matchParentheses.pop();\n                foundLeft = false;\n            }\n        });\n        return matchParentheses;\n    };\n    return {\n        [Syntax.Paragraph](node) {\n            if (helper.isChildNode(node, [Syntax.BlockQuote])) {\n                return;\n            }\n            currentStrInParagraph = [];\n            isInParagraph = true;\n        },\n        [Syntax.Str](node) {\n            if (!isInParagraph) {\n                return;\n            }\n            currentStrInParagraph.push(node);\n        },\n        [`${Syntax.Paragraph}:exit`]() {\n            const missingPairList = foundMissingPairNodes(currentStrInParagraph);\n            // 探索おわり\n            isInParagraph = false;\n            // 全ての対が見つかったなら配列は空になる\n            if (missingPairList.length === 0) {\n                return;\n            }\n            missingPairList.forEach(({ node, index }) => {\n                report(\n                    node,\n                    new RuleError(`${left}の対となる${right}が見つかりません。${left}${right}`, {\n                        index\n                    })\n                );\n            });\n        }\n    };\n}\n"],"file":"pair-checker.js"}